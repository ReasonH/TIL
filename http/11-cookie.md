# 11. 클라이언트 식별과 쿠키

이 장에서는 서버가 통신하는 대상을 식별하는 데 사용하는 기술을 알아본다.

## 11.1 개별 접촉

HTTP는 익명으로 사용하며 상태가 없고 요청과 응답으로 통신하는 프로토콜이다. 웹 서버는 요청을 보낸 사용자를 식별하거나 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.

그리고 이를 이용해 사용자에게 개별 사이트 제공, 맞춤 추천, 사용자 정보 저장, 세션 추적 등을 수행한다.

## 11.2 HTTP 헤더

사용자에 대한 정보를 전달하는 일반적인 HTTP 헤더 3개에 대해 다룬다.

- From: 사용자의 이메일 주소, 악의적으로 이용될 우려가 있어 잘 사용되지 않음
- User-Agent: 사용자의 브라우저 이름, 버전 정보, OS 정보 등의 정보이다. 사용자 식별에는 큰 도움이 되지 않는다.
- Referer: 사용자를 유입하게 한 URL을 가리킨다. 이를 통해 사용자의 사용 형태나 취향을 파악할 수 있다.

## 11.3 클라이언트 IP 주소

웹 서버는 HTTP 요청을 보내는 반대쪽 TCP 커넥션의 IP 주소를 알 수 있다. 그러나 이를 이용해 사용자를 식별하는 방식은 다음과 같은 약점을 갖는다.

- 여러 사용자가 같은 컴퓨터를 사용한다면 각 사용자 구분이 불가능하다.
- 많은 ISP는 사용자가 로그인할 때 동적 IP를 할당한다.
- NAT 장비들은 클라이언트 IP를 방화벽 뒤로 숨기고, 방화벽 IP로 변환한다.
- 보통의 HTTP 프록시와 게이트웨이는 원 서버에 새로운 TCP연결을 한다. 서버는 클라이언트의 IP주소 대신 프록시 서버의 IP 주소를 본다.

IP를 이용하는 방식은 인트라넷과 같이 제한된 영역에서는 적절할 수 있지만, 인터넷에서는 문제가 발생할 수 있다.

## 11.4 사용자 로그인

웹 서버는 사용자 이름과 비밀번호로 인증할 것을 요구해서 사용자에게 명시적 식별 요청을 할 수 있다. HTTP는 WWW-Authentication이나 Authorization 헤더 등을 사용해 웹 사이트에 사용자 이름을 전달하는 체계를 갖고 있다.

절차는 다음과 같다.

1. 브라우저가 사이트로 HTTP 요청
2. 서버는 401 Login Required Code와 WWW-Authenticate 헤더 반환
3. 브라우저가 대화 상자를 띄우면 사용자는 로그인 정보 입력, 브라우저는 기존 요청을 재전송해서 사용자 식별 시도
4. 서버는 사용자 식별정보 인지
5. 다음 요청부터 브라우저는 Authorization 헤더에 사용자 식별정보 토큰을 담아서 전송

## 11.5 Fat URL

어떤 웹 사이트는 사용자의 URL마다 버전을 기술해 사용자를 식별하고 추적했다. 이는 URL 경로에 상태 정보를 추가해 확장하며 이런 URL을 Fat URL이라 한다. 이를 통해 HTTP 트랜잭션을 하나의 세션으로 묶을 수 있다. 그러나 **URL 공유 불가, 캐시 사용 불가능, 서버 부하 가중, 세션 지속성** 등 심각한 문제가 있다.

## 11.6 쿠키

쿠키는 사용자를 식별하고 세션을 유지하는 가장 널리 사용되는 방식이다. 쿠키는 캐시와 충돌할 수 있어, 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않는다.

### 11.6.1 쿠키의 타입

**세션 쿠키**

- 사용자가 사이트를 탐색할 때, 관련 설정을 임시 저장한다.
- 사용자가 브라우저를 닫으면 삭제된다.

**지속 쿠키**

- 사용자가 주기적으로 방문하는 사이트에 대한 로그인, 설정 정보 등을 유지한다.
- 디스크저장되며 컴퓨터를 재시작해도 남아있는다.

### 11.6.2 쿠키는 어떻게 동작하는가

웹 서버는 사이트에 처음 방문한 사용자에 대한 정보가 없다. 따라서 사용자가 다음 방문할 경우 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당한다.

- 쿠키는 이름=값 형태 리스트를 가지고, `Set-Cookie` 같은 HTTP 응답 헤더에 기술되어 전달된다.
- 쿠키는 다양한 정보를 포함할 수도, 단순 DB조회를 위한 ID값만 포함할 수도 있다.
- 브라우저는 서버로부터 온 쿠키를 브라우저 쿠키 DB에 저장하며, 추후 사용자가 같은 사이트를 방문할 때 이 쿠키를 `Cookie`요청 헤더에 기술해 사용한다.

### 11.6.3 쿠키 상자: 클라이언트 측 상태

브라우저는 쿠키 정보를 저장할 책임이 있다. 이 시스템을 클라이언트 측 상태라고 한다. 쿠키 명세에서의 공식적인 이름은 **HTTP 상태 관리 체계**이다.

**구글 크롬 쿠키**

구글 크롬은 Cookies라는 SQLite 파일에 쿠키를 저장한다.

- 주요 필드: **creation_utc, host_key, name, value, path, expire_utc, secure** 등

### 11.6.4 사이트마다 각기 다른 쿠키들

브라우저는 각 사이트에 두 개 혹은 세 개의 쿠키만을 보낸다. 그 이유는 다음과 같다.

- 쿠키 데이터로 인한 성능 저하
- 대부분은 사이트에서 인식하지 않는 무의미한 값
- 잠재적인 개인정보 문제

브라우저는 보통 쿠키를 생성한 서버에게만 쿠키 정보를 전달한다.

**쿠키 Domain 속성**

서버는 쿠키를 생성할 때 Set-Cookie 응답 헤더에 Domain 속성을 기술해서 쿠키를 읽을 수 있는 사이트를 제어할 수 있다.

```
예시 user=”may” 쿠키를 [temp.com](http://temp.com) 도메인을 갖는 모든 사이트에 전달
Set-cookie: user="may"; domain="temp.com"
이후 사용자가 해당 도메인을 갖는 사이트 방문 시, 요청에 Cookie가 적용됨
```

**쿠키 Path 속성**

URL 경로 앞부분을 가리키는 Path 속성을 사용해서 웹 사이트 일부에만 쿠키를 적용할 수도 있다.

```
Set-cookie: user="may"; domain="temp.com"; path=/hello/
```

### 11.6.5 쿠키 구성요소

현재 사용되는 쿠키 명세는 Version 0과 1이 있다. Version 1은 0의 확장이며 잘 쓰이지 않는다.

### 11.6.6 Version 0(넷스케이프) 쿠키

Version 0 쿠키는 다음과 같은 형태다. HTTP 요청 시, 아래 정의된 필터들이 모두 매칭되면서 파기되지 않은 쿠키를 같이 보낸다.

```
Set-Cookie: name=valu [; expires=date] [; path=path] [; domain=domain] [; secure]
Cookie: name1=value1 [; name2=value2] …
```

**Set-Cookie 헤더**

1. 이름=값: 필수 속성, 어떤 조합이든 만들 수 있다.
2. Expires: 선택 속성, 쿠키 생명주기, `요일, DD-MM-YY HH:MM:SS GMT` 규격
3. Domain: 선택 속성, 브라우저가 해당 지정된 도메인을 사용하는 호스트명으로만 쿠키를 전송한다. 명시하지 않는 경우 기본 값은 서버의 호스트명
4. Path: 선택 속성, 특정 문서에만 쿠키 전송, 명시하지 않는 경우 Set-Cookie 응답을 전달하는 URL 경로 사용
5. Secure: 선택 속성, SSL 사용 시에만 쿠키 전송

### 11.6.7 Version 1 (RFC 2965) 쿠키

- Version 0와 호환되며 좀 더 복잡하다.
- Version 0보다 더 많은 속성이 있다.

**Version 1 Cookie 헤더**

Version 1에서는 Cookie 전송 시, 현재 사이트에 들어맞는 필터를 기술하여 전송한다. ($표시 사용)

**Version 1 Cookie2 헤더와 버전 협상**

Cookie2 요청 헤더는 각기 다른 쿠키 버전을 지원하는 클라이언트-서버 간의 호환성 협상 용도로 사용된다.

### 11.6.8 쿠키와 세션 추적

쿠키는 웹에서 수차례의 트랜잭션을 만들어내는 사용자를 추적하는 데 사용한다.

예시로, 쇼핑을 위해 아마존에 접속하면 일련의 리다이렉트, URL 리라이트, 쿠키 설정 등을 통해 서버가 식별 정보를 첨부하기 위한 연속 트랜잭션이 수행된다.

### 11.6.9 쿠키와 캐싱

개인 정보 보호를 위해 쿠키와 관련된 문제를 캐싱하는 것은 주의해야 한다.

다음은 캐시를 다루는 기본 원칙에 대한 안내이다.

- 캐시되지 말아야 할 문서가 있다면 표시한다.
  - `Cache-Control: no-cache` 헤더 사용
- Set-Cookie 헤더를 캐시하는 것에 유의하라
  - 같은 Set-Cookie 헤더를 여러 사용자에게 보내게 되면 사용자 추적에 실패할 수 있다.
  - 응답을 저장하기 전 Set-Cookie를 제거하는 캐시도 있다. 이 경우 클라이언트가 Set-Cookie 헤더 정보가 없는 데이터를 받게 되어 문제가 발생할 수 있다.
  - `Cache-Control: must-revalidate, max-age=0` 등으로 문제를 개선할 수 있다.
- Cookie 헤더를 갖는 요청을 주의하라
  - 요청이 Cookie 헤더와 함께 오면 결과 콘텐츠가 개인정보를 담고 있을 수도 있다.
  - 보수적인 캐시는 Cookie 헤더가 포함된 요청의 응답은 캐시하지 않을 것이다.

### 11.6.10 쿠키, 보안 그리고 개인정보

원격 DB에 개인정보를 저장하고 해당 데이터의 키를 쿠키에 저장하는 방식을 사용한다면, 클라이언트와 서버 사이에 예민한 데이터가 오가는 것을 줄일 수 있다.

개인정보 정책에만 유의한다면, 쿠키에 관련된 위험성보다 세션 조작 등에서의 편리함이 더 크다.
