# 7. 캐시

웹 캐시는 자주 쓰이는 문서의 사본을 자동 보관하는 HTTP 장치다.

## 7.1 불필요한 데이터 전송

캐시를 이용하면 첫 번째 서버 응답을 보관하고, 뒤이은 요청에 응답으로 사용함으로써 원본 웹 서버에 대한 부하와 네트워크 비용을 줄여준다.

## 7.2 대역폭 병목

네트워크는 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다. 클라이언트가 서버에 접근할 때의 속도는 경로 상의 가장 느린 네트워크 속도와 같기 때문에 LAN에서 캐시 사본을 가져온다면, 성능을 대폭 개선할 수 있다.

## 7.3 갑작스런 요청 쇄도

캐싱은 갑작스런 요청 증가에 대응하기 위해 특히 중요하다. 다수의 동시 요청으로 생기는 트래픽은 네트워크에 장애를 야기한다.

## 7.4 거리로 인한 지연

거리 자체도 지연이 될 수 있다.

## 7.5 적중과 부적중

적중: 캐시에 의해 요청 처리

부적중: 캐시에 의해 처리 불가, 원서버로 전달

### 7.5.1 재검사

원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시가 최신인지 서버를 통해 점검해야 한다.

대부분의 캐시는 클라이언트가 오래된 캐시를 요청했을 때, 원 서버에 재검사 요청을 보낸다. 만약 사본이 여전히 유효하다는 304응답이 온다면 캐시를 클라이언트에게 제공한다. 이를 느린 적중이라 한다. 원 서버와 검사를 위한 통신을 하지만 객체를 받아오지 않기 때문에 부적중보다는 빠르다.

**If-Modified-Since**

GET 요청 시 이 헤더를 사용하면 캐시된 시간 이후에 변경된 경우 사본을 보내달라는 의미가 된다.

**재검사 적중:** 만약 서버 객체가 변경되지 않았다면 304 응답을 보낸다.

**재검사 부적중:** 캐시된 사본과 다르다면 서버는 200 응답과 콘텐츠 전체를 전달해준다.

**객체 삭제:** 서버 객체가 삭제된 경우 404 응답을 보내며, 캐시는 사본을 삭제한다.

### 7.5.2 적중률

캐시가 요청을 처리하는 비율이다. 40%면 적당한 수준으로 여겨진다. 보통 크기의 캐시라도 상당한 트래픽을 줄이고 성능을 개선할 수 있다. 문서 단위 적즁률 개선은 전체 대기 시간을 감소시키고, 전체 대역폭 절약을 최적화한다.

### 7.5.3 바이트 적중률

바이트 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다. 이는 트래픽이 절감된 정도를 포착한다. 바이트 단위 적중률 개선은 대역폭 절약을 최적화한다.

### 7.5.4 적중과 부적중의 구별

HTTP는 클라이언트에게 응답이 캐시 적중인지, 원 서버 응답인지 제공할 방법이 없다. 클라이언트에서 알아내는 방법은 Date 헤더 비교 등이 있다.

## 7.6 캐시 토폴로지

개인 전용 캐시: 개인만을 위한 캐시, 한 명의 사용자가 자주 찾는 페이지

공용 캐시: 사용자 집단에 자주 쓰이는 페이지

### 7.6.1 개인 전용 캐시

웹 브라우저는 개인 전용 캐시를 내장하고 있다. 대부분 브라우저는 자주 쓰이는 문서를 디스크와 메모리에 캐시하며 사용자가 사이즈 등을 설정할 수 있도록 한다.

### 7.6.2 공용 프록시 캐시

공유 캐시는 프록시 캐시라 불리는 공유된 프록시 서버이다. 공용 캐시는 여러 사용자가 접근하기에 불필요 트래픽을 줄일 더 많은 기회가 있다. 프록시 캐시는 앞서 설명했듯 프록시를 위한 규칙에 따라 브라우저가 사용하도록 설정할 수 있다.

### 7.6.3 프록시 캐시 계층들

클라이언트 주변에는 작고 저렴한 캐시를, 계층 상단에는 더 크고 강력한 공유 캐시를 사용하는게 합리적이다.

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

몇몇 네트워크는 복잡한 캐시망을 만든다. 캐시망의 프록시 캐시는 서로 대화하며 캐시 커뮤니케이션의 결정을 동적으로 내린다.

이러한 복잡한 캐시 관계는 서로 다른 조직들이 그들의 캐시를 연결하고 서로를 찾아볼 수 있도록 해준다. 선택적 피어링을 지원하는 캐시는 형제 캐시라고 불린다.

## 7.7 캐시 처리 단계

오늘날의 상용 프록시 캐시는 꽤 복잡하다. 매우 고성능이면서도 HTTP 및 다른 기술의 고급 기능을 지원하도록 만들어졌다.

### 7.7.1 단계 1: 요청 받기

캐시는 네트워크 커넥션에서의 활동을 감지하고 들어오는 데이터를 읽어들인다.

### 7.7.2 단계 2: 파싱

캐시는 요청 메시지를 여러 부분을 파싱하여 헤더 부분을 조작하기 쉬운 자료구조에 담는다.

### 7.7.3 단계 3: 검색

캐시는 URL을 알아내고 해당하는 로컬 사본이 메모리, 디스크, 근처 PC 등에 있는지 확인한다. 만약 로컬에서 가져올 수 없다면 원 서버나 부모 프록시에서 가져오거나 실패를 반환한다.

### 7.7.4 단계 4: 신선도 검사

보유한지 일정 시간이 지난 캐시는 서버를 통해 재검사를 해야 한다. HTTP에서의 검사 규칙은 매우 복잡하다.

### 7.7.5 단계 5: 응답 생성

캐시는 서버 응답 헤더를 토대로 캐시 응답 헤더를 생성한다. 캐시는 클라이언트에 맞게 헤더를 적절하게 조정, 만료 및 갱신 정보 삽입 등의 작업을 한다. (Date 헤더를 조정해서는 안된다.)

### 7.7.6 단계 6: 전송

응답 헤더가 준비되면 캐시는 응답을 클라이언트에게 전달한다.

### 7.7.7 단계 7: 로깅

대부분 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지한다.

## 7.8 사본을 신선하게 유지하기

HTTP는 캐시된 사본과 서버의 동기화를 유지할 수 있게 해주는 단순한 메커니즘을 갖고 있다. HTTP는 이를 서버 재검사라고 부른다.

### 7.8.1 문서 만료

HTTP는 `Cache-Control`라는 헤더들을 이용해 원 서버가 문서에 유효기간을 붙일 수 있게 한다.

### 7.8.2 유효기간과 나이

1.1 버전에서 사용되는 유효기간 헤더인 `Cache-Control`은 만료시킬 절대 시간을 초로 나타낸다.

### 7.8.3 서버 재검사

캐시된 문서가 만료되었다는 것은 문서가 원본과 달라졌다는 것이 아닌, 검사할 시간임을 뜻한다.

- 원 서버 검사 결과, 변경 된 경우 → 사본 갱신 및 클라이언트 전달
- 원 서버 검사 결과, 변경되지 않은 경우 → 새로운 헤더들(만료일 등)을 가져와 캐시 내 헤더 갱신

HTTP는 캐시가 다음 중 하나를 반환하는 행동을 할 것을 요구한다.

1. ‘충분히 신선한’ 캐시된 사본
2. 원 서버와 재검사되었기 때문에, 충분히 신선함을 확신할 수 있는 캐시된 사본
3. 에러 메시지
4. 경고 메시지가 부착된 캐시된 사본

### 7.8.4 조건부 메서드와의 재검사

HTTP는 캐시가 서버에게 ‘조건부 GET’이라는 요청을 보낼 수 있도록 한다. 이는 신선도 검사와 객체를 받아오는 것을 하나로 결합하며, GET 요청 메시지에 특별한 조건부 헤더를 추가함으로써 시작된다. HTTP는 다섯 가지 조건부 요청 헤더를 정의하는데, 캐시 재검사를 하는데는 다음 두 가지가 가장 유용하다.

### 7.8.5 If-Modified-Since: 날짜 재검사

흔히 IMS 요청으로 불린다. 리소스가 특정 날짜 이후 변경된 경우에만 본문을 보내달라고 한다. 서버응답의 `Last-Modified`헤더와 함께 동작한다.

- 변경 된 경우 평범한 GET 요청으로 동작
- 변경되지 않은 경우 304 응답, 갱신이 필요한 헤더들은 포함해서 응답
- 해당 헤더 값을 날짜 비교가 아니라 문자열 비교로 사용하기도 함

### 7.8.6 If-None-Match: 엔티티 태그 재검사

작은 단위로 갱신되는 문서이거나, 같은 데이터를 포함하지만 날짜만 갱신되는 경우 등 최근 변경 일시 재검사가 행해지기 어려운 경우가 있다.

퍼블리셔가 문서 변경 시, 문서의 엔티티 태그를 새로운 버전으로 표현할 수 있다. 이 경우 캐시는 새 문서 사본을 얻기 위해 `If-None-Match` 조건부 헤더를 사용할 수 있다.

### 7.8.7 약한 검사기와 강한 검사기

엔티티 태그는 캐시 검사기이다.

강한 엔티티 태그는 대응하는 엔티티 값이 어떻게 바뀌든 매번 반드시 같이 바뀌어야 한다.

약한 엔티티 태그는 대응하는 엔티티에 유의미한 변경이 있을 때마다 변경되어야 한다.

### 7.8.8 언제 엔티티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

HTTP/1.1 클라이언트는 서버가 반환한 헤더에 따라 유연하게 사용하면 된다. HTTP/1.1 서버는 가능하면 엔티티 태그 검사기를 보내야 하며 약한 엔티티 태그를 사용하거나 Last-Modified 값을 같이 보내는 것도 선호한다.

## 7.9 캐시 제어

HTTP는 문서가 만료까지 전, 얼마나 오랫동안 캐시할 수 있을 것인지 서버가 설정할 수 있는 여러 방법을 정의한다.

### 7.9.1 no-cache와 no-store 응답 헤더

캐시가 검증되지 않은 캐시 객체로 응답하는 것을 막기 위한 HTTP/1.1 헤더이다.

`Cache-Control: no-sotore`: 캐시가 응답의 사본을 만드는 것을 금지, 캐시는 클라이언트에게 응답 전달 후 객체 삭제

`Cache-Control: no-cache`: 로컬 캐시 가능하지만 서버와의 재검사 없이 클라이언트에 제공할 수 없도록 함

### 7.9.2 Max-Age 응답 헤더

`Cache-Control: max-age`: 서버로부터 받은 리소스가 최신 상태라고 판단할 최대 시간을 초로 지정

`Cache-Control: s-maxage`: 위와 같지만 공용 캐시에만 적용

### 7.9.3 Expires 응답 헤더

초 단위의 시간 대신 만료날짜 입력

### 7.9.4 Must-Revalidate 응답 헤더

`Cache-Control: Must-Revalidate`: 캐시는 만료된 객체를 제공할 수 있도록 설정할 수 있다. 만약 만료 정책을 엄격히 따르길 원한다면 객체의 만료된 사본을 서버와의 최초 재검사 없이 제공해서는 안되도록 이 헤더를 설정해야 한다.

### 7.9.5 휴리스틱 만료

응답이 `max-age` 및 `Expires` 중 어느 헤더도 포함하지 않는다면, 캐시는 휴리스틱하게 age를 계산하며 그 결과가 24시간보다 크다면 응답 헤더에 경고가 추가되어야 한다. 이 때 사용하는 알고리즘은 LM알고리즘이 있다.

### 7.9.6 클라이언트 신선도 제약

웹브라우저는 프록시 캐시의 콘텐츠를 강제로 갱신시키는 리로드 버튼을 갖는다. 이는 Cache-Control 요청 헤더가 추가된 GET을 발생시켜서, 강제 재검사를 수행하거나 서버로부터 컨텐츠를 무조건 가져온다. 클라이언트는 Cache-Control 요청 헤더를 조정해 만료 제약을 엄격하게 하거나 느슨하게 할 수 있다.

### 7.9.7 주의할 점

문서 만료는 완벽한 시스템이 아니다. 장기간 보관되는 문제를 방지하기 위해 많은 경우 유효기간을 길게 잡지 않는다.

## 7.10 캐시 제어 설정

패스

## 7.11 자세한 알고리즘

관심 없으면 건너뛰래서 패스

## 7.12 캐시와 광고

### 7.12.1 광고 회사의 딜레마

캐싱이 완벽하게 동작한다면 원 서버는 HTTP 접근을 전혀 수신하지 않게 된다. 만약 광고의 접근 횟수에 따라 돈을 벌고 있고, 그 광고가 캐싱되어 있다면 이는 문제가 될 것이다.

### 7.12.2 퍼블리셔의 응답

광고 시청 수를 가로채지 못하도록 캐시 무력화 기법을 사용하기도 한다. 그러나 이는 캐싱의 긍정적인 효과를 감소시킨다. 이상적인 방법은 캐시가 트래픽을 흡수하고, 적중이 얼마나 많이 일어났는지 제공자에게 알리는 것이다.

- ex) 모든 접근에 대해 원 서버와 재검사(본문 전달은 X), 물론 이는 트랜잭션을 느려지게 만든다.

### 7.12.3 로그 마이그레이션

이상적인 해결책 하나는 서버로 요청이 가지 않도록 하고, 캐시 적중에 대한 로그를 서버에 전달하는 것이다.

### 7.12.4 적중 측정과 사용량 제한

RFC 2227 “Simple Hit-Metering and Usage-Limiting for HTTP”는 더 간단한 방법을 정의한다. 이는 특정 주기로 URL에 대한 캐시 적중 횟수를 Meter 헤더에 담아 서버에 전달한다. 서버는 이를 통해 캐시된 문서가 적중한 횟수를 정기적으로 업데이트할 수 있다.

추가적으로 서버는 캐시가 서버에게 보고하기 전까지 문서를 제공할 수 있는 횟수, 소모할 수 있는 처리 시간 등을 조정할 수 있다. 이를 통해 서버는 캐시된 리소스가 보고되기 전까지 얼마나 사용될 수 있는지를 제어할 수 있다.
