# 4. 커넥션 관리

## 4.1 TCP 커넥션

모든 HTTP 통신은 TCP/IP를 통해 이루어진다. 클라이언트는 서버와 커넥션을 맺을 수 있으며 일단 커넥션이 맺어지면 메시지들은 손실, 손상, 순서변경 없이 안전하게 전달된다.

### **4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP**

HTTP 커넥션은 몇몇 규칙을 제외하고 TCP 커넥션에 불과하다. TCP는 HTTP에 신뢰할 만한 통신 방식을 제공한다.

### **4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.**

HTTP가 메시지를 전송할 때, 현재 연결되어 있는 TCP 커넥션을 통해 메시지 데이터를 순서대로 보낸다. TCP/IP 소프트웨어는 스트림을 세그먼트 단위로 나누고, 세그먼트를 IP 패킷에 담아 인터넷을 통해 데이터를 전달한다.

IP 패킷이 포함하는 정보는 패킷 헤더, TCP 세그먼트 헤더, TCP 데이터 조각 등이다.

### **4.1.3 TCP 커넥션 유지하기**

컴퓨터는 TCP 커넥션을 여러개 가지며 TCP는 포트 번호를 통해 여러 커넥션을 유지한다. TCP는 발신지/수신지 IP와 포트 4가지 정보로 유일한 커넥션을 생성한다.

### **4.1.4 TCP 소켓 프로그래밍**

소켓 API를 사용하면 TCP 종단 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다. 핸드셰이킹, 데이터 스트림과 패킷의 분할, 재조립에 대한 모든 사항을 숨긴다.

---

## 4.2 TCP 성능에 대한 고려

HTTP는 TCP 바로 위의 계층이기 때문에 HTTP 성능은 그 아래 계층인 TCP 성능에 영향을 받는다.

### **4.2.1 HTTP 트랜잭션 지연**

복잡하고 동적인 작업을 실행하지 않는 한 대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생한다. 이에 대한 원인은 여러가지가 있다.

1. URI의 호스트에 방문한 적이 없으면 IP변환에 시간이 걸릴 수 있음 (최근 성능이 좋아서 거의 해당안됨)
2. 커넥션 요청-응답 (커넥션 설정) 시간
3. 요청 메시지 전달 시간
4. 응답 메시지 전달 시간

이런 지연들은 HW 성능, NW 서버 전송 속도, 요청/응답 메시지 크기 등에 따라 달라진다.

### **4.2.2 성능 관련 중요 요소**

고성능의 HTTP SW개발을 위한 항목들에 대해 설명한다.

### **4.2.3 TCP 커넥션 핸드셰이크 지연**

새로운 TCP 커넥션을 열 때 TCP SW에서는 커넥션 조건을 맞추기 위해 연속 IP 패킷 교환 (핸드셰이크)이 일어난다. 작은 데이터 전송에 커넥션이 사용된다면 성능을 크게 저하시킬 수 있다.

- 커넥션 핸드셰이킹 시, SYN 구문의 데이터가 비대한 것이 가장 큰 문제

### **4.2.4 확인응답 지연**

TCP는 성공적 데이터 전송 보장을 위해 자체적 확인 체계를 갖는다. 각 세그먼트는 순번과 무결성 체크섬을 갖고, 세그먼트가 온전히 수신되면 확인응답 패킷을 송신자에게 반환한다.

확인응답은 그 크기가 작기에 같은 방향으로 송출되는 데이터 패킷에 piggybag 하는데, 대부분 TCP 스택은 네트워크 효율을 위해 일정 시간 응답을 버퍼에 대기하며 송출 데이터 패킷을 기다리는 확인응답 지연 알고리즘을 구현한다. 요청과 응답 형식으로만 이루어진 HTTP 동작은 이런 piggybag 기회를 감소시킨다.

문제를 해결하기 위해 해당 옵션을 비활성화하거나 관련 기능을 수정할 수도 있다.

**그러나 이런 작업을 위해서는 이미 구현된 알고리즘과 옵션이 피하려는 문제가 무엇인지를 파악하고, 해당 문제를 일으키지 않을 것이라는 확신이 있어야 한다.**

### **4.2.5 TCP 느린 시작**

TCP 커넥션은 시간이 지나며 자체 튜닝되어서 처음에는 커넥션 최대 속도를 제한하고, 데이터 전송이 성공됨에 따라서 속도 제한을 높여나간다. 이를 TCP의 느린 시작이라 한다.

TCP 느린 시작은 한 번에 전송할 수 있는 패킷 수를 제한하는데, 데이터를 성공적으로 전달할 수록 더 많은 패킷을 전송할 수 있게 된다. 이런 혼잡제어 기능 덕에 새로운 커넥션은 이미 데이터를 어느정도 주고받은 커넥션보다 느리다.

### **4.2.6 Nagle 알고리즘과 TCP_NODELAY**

TCP는 어떤 크기의 데이터라도 TCP 스택으로 전송할 수 있도록 데이터 스트림 인터페이스를 제공한다. 그러나 각 세그먼트는 상당한 플래그와 헤더를 포함한다. 작은 데이터를 갖는 많은 수의 패킷을 전송한다면 성능이 떨어지게 된다. 네이글 알고리즘은 네트워크 효율을 위해 패킷 전송 전 많은 TCP 데이터를 한 개의 덩어리로 합친다.

이는 HTTP에서 성능에 관한 여러 문제를 발생시킨다.

1. 작은 HTTP 메시지는 패킷을 채우지 못해 추가적인 데이터를 기다리며 지연된다.
2. 확인응답 지연 알고리즘과는 최악의 조합이다.

이를 위해 HTTP 스택에 TCP_NODELAY 파라미터를 설정해 네이글 알고리즘을 비활성화 할 수 있다. 이때, 작은 크기 패킷이 많이 생기지 않도록 큰 크기의 데이터 덩어리를 만들어야 한다.

### **4.2.7 TIME_WAIT 누적과 포트고갈**

TCP 커넥션 종단에서 TCP 커넥션을 끊으면 종단에서는 IP 주소와 포트번호를 메모리 영역에 기록한다. 이는 같은 주소와 포트 번호를 사용하는 동일한 TCP 커넥션이 일정 시간 생성되지 않도록 한다. 일반적으로 세그먼트 생명주기의 2배 (약 2분)간 유지된다. 이는 이전 커넥션과 연관된 패킷이 이전 커넥션과 동일 정보를 갖는 새로운 커넥션에 삽입되는 문제를 방지한다.

일반적인 상황에서는 이게 문제가 되지 않지만, 제한된 클라이언트를 사용하는 성능 측정에서는 문제의 소지가 있다.

```
각각 1대의 클라이언트와 서버를 가정한다.
커넥션 정보 <발신 IP, 발신 포트, 수신 IP, 수신 포트> 중 변경 가능한 정보는 발신 포트 뿐이다.

클라이언트가 서버에 접속할 때마다 유일한 커넥션 생성
포트 60,000개를 가정, TIME_WAIT는 2MSL 가정
(60000/120) => 초당 500커넥션 가능

즉 서버가 초당 500개 이상의 트랜잭션을 처리한다면 포트고갈이 일어날 수 있음
```

문제 해결을 위해서는 부하 생성 장비를 더 많이 사용하거나, 여러 가상 IP를 사용할 수 있다.

---

## 4.3 HTTP 커넥션 관리

흔히 잘못 이해하고 있는 HTTP 커넥션 헤더에 대해 알아보고, HTTP 커넥션 최적화 기술을 알아본다.

### **4.3.1 흔히 잘못 이해하는 Connection 헤더**

HTTP는 클라이언트-서버 간 중개 서버가 놓이는 것을 허락한다. 특정 경우에 인접한 커넥션에만 적용될 옵션을 기술해야 할 때가 있는데, 이 때 Connection 헤더를 사용한다.

Connection 헤더에는 다음의 세 종류 토큰이 전달될 수 있다.

1. HTTP 헤더 필드명 (여기 적힌 헤더들을 hop-by-hop 헤더라고 함)
2. 임시적 토큰 값, 커넥션에 대한 비표준(커스텀) 옵션
3. close, 커넥션이 작업 완료 후 종료

HTTP 애플리케이션이 Connection 헤더와 함께 메세지를 받으면 수신자는 송신자에게 온 요청에 기술된 모든 옵션을 적용한다. 그리고 다음 홉에 전달하기 전 Connection에 기술된 모든 헤더를 HTTP 요청 헤더에서 찾아 삭제한다. (Connection에 기술되어 있지 않아도 hop-by-hop 헤더인 것들도 있다.)

```
HTTP/1.1 200 OK
Cache-control: max-age=3600
Connection: meter, close, bill-my-credit-card
Meter: max-uses=3

해석
1. Meter 헤더를 다른 커넥션으로 전달하면 안 된다. (수신자는 Meter 헤더를 삭제한다.)
2. bill-my-credit-card라는 비표준 옵션을 사용한다.
3. close를 통해 트랜잭션 작업 완료 후 커넥션이 끊긴다.
```

### **4.3.2 순차적인 트랜잭션 처리에 의한 지연**

커넥션 관리가 제대로 이루어지지 않으면 TCP 성능이 매우 안좋아 질 수 있다. 여러 트랜잭션이 필요한 웹 페이지에서 각 트랜잭션이 새로운 커넥션을 사용한다면, 시작 지연이 발생할 것이다. 다음 장에서 HTTP 커넥션 성능을 향상시킬 방법들에 대해 알아본다.

---

## 4.4 병렬 커넥션

HTTP는 클라이언트가 여러 개의 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다.

### **4.4.1 병럴 커넥션은 페이지를 더 빠르게 내려받는다.**

- 단일 커넥션의 대역폭 제한, 커넥션이 동작하지 않고 있는 시간을 활용
- 하나의 커넥션으로 객체를 로드할 때의 대역폭 제한과 대기시간을 줄임
- 각 커넥션의 지연 시간을 겹치게 한다.

### **4.4.2 병렬 커넥션이 항상 더 빠르지는 않다**

네트워크 대역폭이 좁을 때는 대부분 시간을 데이터를 전송하는 데만 쓸 것이다. 제한된 대역폭 내에서 각 객체 전송은 느리기 때문에 성능상 장점이 거의 없다. 또한, 다수의 커넥션은 메모리를 많이 소모하는 등 문제가 있다. 따라서 브라우저는 자체적으로 적은 수의 병렬 커넥션만 허용한다.

### **4.4.3 병럴 커넥션이 더 빠르게 느껴질 수 있다.**

사람들은 총 다운로드 시간이 더 걸리더라도 시각적으로 빠르게 느껴지는 것을 선호한다.

---

## 4.5 지속 커넥션

웹 클라이언트는 보통 같은 사이트에 여러 커넥션을 맺는다. 따라서 서버에 HTTP 요청을 하기 시작한 애플리케이션은 웹페이지 내의 이미지 등을 가져오기 위해 그 서버에 또 요청하게 될 것이다. 이를 사이트 지역성이라 한다.

HTTP/1.1 을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 재사용할 수 있다. 이는 핸드셰이크 과정에 필요한 시간을 절약하고, TCP의 느린 시작으로 인한 지연을 피할 수 있게 한다.

### **4.5.1 지속 커넥션 vs 병렬 커넥션**

지속 커넥션을 잘못 관리할 경우 수많은 커넥션이 쌓이고, 불필요한 리소스 낭비로 이어질 수 있다. 지속 커넥션은 병렬 커넥션과 함께 사용될 때 가장 효과적이다. HTTP는 적은 수의 병렬 커넥션을 맺고 그것을 유지한다.

### **4.5.2 HTTP/1.0+의 Keep-Alive 커넥션**

keep-alive 커넥션은 맺고 끊는 작업이 없어져 시간을 단축시킨다.

### **4.5.3 Keep-Alive 동작**

keep-alive는 1.1 스펙에서 제외됐지만, 여전히 많이 사용되고 있기 때문에 동작 방식을 알 필요가 있다.

1. HTTP/1.0 keep-alive를 구현한 클라이언트는 커넥션 유지를 위해 요청에 Connection: Keep-Alive 헤더를 포함시킨다.
2. 서버는 다음 요청도 이 커넥션을 통해 받고자 한다면, 응답에 같은 헤더를 포함한다.
3. 만약 응답에 Connection: Keep-Alive가 포함되지 않으면 클라이언트는 서버가 keep-alive를 지원하지 않으며 응답 메시지 전송 이후 서버 커넥셔을 끊을 것이라 추정

### **4.5.4 Keep-Alive 옵션**

- timout: 응답 헤더를 통해 보낸다. 커넥션이 얼마간 유지될 것인지 의미한다.
- max: 응답 헤더를 통해 보낸다. 커넥션이 몇 개의 HTTP 트랜잭션을 처리할 때까지 유지될 것인지 의미한다.
- 그 외에 디버깅을 목적으로 하는 임의 속성을 지원하기도 한다.

Keep-Alive 헤더는 Connection: Keep-Alive 헤더가 있을 때만 사용할 수 있다.

### **4.5.5 Keep-Alive 커넥션 제한과 규칙**

- keep-alive는 HTTP/1.0에서 기본 사용되지 않는다.
- 커넥션 유지를 위해서는 모든 메시지에 `Connection: Kepp-Alive` 헤더를 포함해야 한다.
- 클라이언트는 `Connection: Keep-Alive` 응답 헤더를 보고 서버가 커넥션을 끊을 것을 추측 가능하다.
- 커넥션이 끊어지기 전에 엔티티 본문 길이를 정확히 알아야 커넥션을 유지할 수 있다.
- 프록시와 게이트웨이는 메시지를 전달하거나 캐시에 넣기 전에 반드시 Connection에 명시된 헤더를 지워야한다.
- keep-alive 커넥션은 Connection 헤더를 인식할 수 없는 프록시 서버와 맺어지면 안된다.
- 클라이언트는 응답 전체를 모두 받기 전 커넥션이 끊어질 경우, 별다른 문제가 없으면 요청을 다시보낼 수 있게 준비되어 있어야 한다.

### **4.5.6 Keep-Alive와 멍청한 프록시**

프록시는 Connection 헤더를 이해하지 못해서 해당 헤더를 삭제하지 않고 그대로 다음 프록시에 전달한다. 이 때 다음의 문제가 발생할 수 있다.

1. 웹 클라이언트는 `Connection: Kepp-Alive` 헤더와 함께 메시지를 보내고, 커넥션 유지하기를 요청한다.
2. 프록시는 Connection 헤더를 이해하지 못하고, 다음 서버에 메시지를 그대로 전달한다.
   1. 그러나 Connection 헤더는 hop-by-hop 헤더이다.
3. 웹 서버는 프록시와 커넥션을 유지하는 것에 동의하고, 프록시와 keep-alive 규칙에 맞게 통신하는 것으로 판단한다.
   1. 그러나 프록시는 keep-alive를 이해하지 못한다.
4. 프록시는 웹 클라이언트에 `Connection: Keep-Alive`를 포함한 응답 메시지를 전달한다.
   1. 이 시점에 클라이언트와 서버는 커넥션을 유지하고 있다고 생각한다.
5. 프록시는 커넥션이 끊기길 기다리지만, 서버는 커넥션을 끊지 않는다.
6. 프록시는 같은 커넥션상에서 다른 요청이 오는 경우는 예상하지 못한다. 클라이언트가 다음 요청을 보내면 아무런 응답없이 로드 중 메시지만 나온다.
7. 브라우저는 자신이나 서버가 타임아웃이 나서 커넥션이 끊길 때까지 기다린다.

이런 종류의 잘못된 통신을 피하려면 프록시는 Connection헤더와 해당 헤더에 명시된 헤더들을 절대 전달하면 안된다.

### 4.5.7 Proxy-Connection 살펴보기

모든 헤더를 전달하는 문제를 해결하기 위해서 Proxy-Connection 헤더를 사용할 수 있다.

1. 브라우저가 Connection 대신 Proxy-Connection 헤더를 프록시에 전달한다.
2. 멍청한 프록시는 Proxy-Connection 헤더를 서버에 그대로 전달, 서버는 무시
3. 영리한 프록시는 Proxy-Connection 헤더를 Connection 헤더로 바꿔서 전달, 의도대로 동작

이 방식은 클라이언트와 서버 사이 한 개의 프록시만 있는 경우에만 동작한다.

멍청한 프록시 양옆에 영리한 프록시가 있다면 동일한 문제가 발생한다. 게다가 프록시는 네트워크 상에서 보이지 않는 경우가 많기 때문에, 웹 애플리케이션들이 지속 커넥션을 명확히 구현하는 것은 중요하다.

### 4.5.8 HTTP/1.1의 지속 커넥션

HTTP/1.1에서는 keep-alive 커넥션을 지원하지 않는 대신, 설계가 더 개선된 지속 커넥션을 지원한다.

1.1의 지속 커넥션은 기본적으로 활성화되어 있으며 모든 커넥션을 지속 커넥션으로 취급한다. 응답에 `Connection: close` 가 없으면 커넥션을 계속 유지하자는 것으로 추정한다.

### 4.5.9 지속 커넥션의 제한과 규칙

- 클라이언트가 요청에 `Connection: close`헤더를 포함해 보냈으면, 해당 커넥션으로 추가 요청이 불가능
- 커넥션에 있은 모든 메시지가 자신의 길이 정보를 정확히 가져야만 커넥션 지속이 가능
  - 본문이 정확한 Content-Length 값을 가지거나 청크 전송 인코딩이 되어 있어야함
- HTTP/1.1 프록시는 클라이언트와 서버 각각에 지속 커넥션을 맺고 관리해야함
- HTTP/1.1 프록시 서버는 클라이언트가 커넥션 관련 기능에 대한 지원범위를 알고 있지 않는 한 지속 커넥션을 맺으면 안된다.
- HTTP/1.1 기기는 언제든지 커넥션을 끊을 수 있다.
- HTTP/1.1 애플리케이션은 중간에 끊어지는 커넥션을 복구할 수 있어야한다.
- 클라이언트는 전체 응답을 받기 전 커넥션이 끊어지면, 다시 보낼 준비가 되어 있어야 한다.
- 하나의 사용자 클라이언트는 서버 과부하 방지를 위해 최대 2개의 커넥션만을 유지해야 한다.
  - ex) N명의 사용자가 서버로 접근하려 한다면, 프록시는 서버나 상위 프록시에 최대 2N개의 커넥션을 유지해야 한다.

## 4.6 파이프라인 커넥션

HTTP/1.1은 지속 커넥션을 통해서 요청을 파이프라이닝 할 수 있다. 즉 **응답 도착 전 추가적인 요청을 보낼 수 있는 것이다.** 파이프라인에는 여러 제약 사항이 있다.

- HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전, 파이프라인을 이어서는 안 된다.
- HTTP 응답은 요청 순서와 같아야 한다. HTTP 메시지는 순번이 없어 정렬 불가능하기 때문이다.
- HTTP 클라이언트는 커넥션이 끊기는 경우 파이프라인 내에 남은 요청을 다시 보낼 준비가 되어 있어야 한다.
- 멱등성 보장이 안되는 요청은 파이프라인을 통하면 안된다.

## 4.7 커넥션 끊기에 대한 미스터리

커넥션 관리에는 명확한 기준이 없다.

### 4.7.1 마음대로 커넥션 끊기

클라이언트, 서버, 프록시 어디서든 TCP 커넥션을 끊을 수 있다. 에러가 있는 상황에서는 메시지 전송 도중 끊길 수도 있는 것이다. 예를 들어 서버가 유휴상태에 있는 파이프라인 지속 커넥션을 끊는 시점에, 클라이언트가 데이터를 전송하지 않을 것이라 확신하지 못한다.

### 4.7.2 Content-Length와 Truncation

각 HTTP 응답은 본문의 정확한 크기 값을 가지는 Content-Length 헤더를 가지고 있어야 한다. 커넥션이 끊겼다는 응답을 받은 후, Content-Length에 문제가 있는 경우 수신자는 서버에 정확한 길이를 물어봐야 한다.

- 프록시는 Content-Length를 정정하지 말고 메시지를 받은 그대로 전달해야 한다.

### 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성

커넥션은 에러가 없어도 언제든 끊길 수 있다. 이 경우에 대응 처리를 하는 것은 파이프라인 커넥션에서 더욱 어렵다. 비멱등 요청인 경우는 파이프라인을 사용하지 말고, 추가 요청을 보내려면 이전 요청에 대한 응답을 받을 때까지 기다려야 한다. 또한, 비멱등 요청에 대한 자동 재시도는 피해야 한다.

### 4.7.4 우아한 커넥션 끊기

TCP 커넥션은 양방향이다.

**저체 끊기와 절반 끊기**

애플리케이션은 TCP 입력/출력 채널 중 한 개만 끊거나(절반 끊기) 둘 다 끊을 수 있다.(전체 끊기)

**TCP 끊기와 리셋 에러**

애플리케이션이 각기 다른 HTTP 클라이언트, 서버, 프록시와 통신할 때, 그리고 파이프라인 지속 커넥션을 사용하는 경우 예상치 못한 쓰기 에러를 방지하기 위해 절반 끊기를 사용해야 한다.

- 일반적으로는 커넥션의 출력 채널을 끊는 것이 안전하다.
- 클라이언트가 더 이상 데이터를 보내지 않을 것을 확신할 수 없는 이상, 입력 채널을 끊는 것은 위험하다.
  - 끊긴 입력 채널에 데이터를 전송하면 TCP 에러가 발생하며 대부분 운영체제는 이런 경우 버퍼에 저장된 데이터를 모두 삭제한다. 이 때 정상적으로 도착했지만 아직 처리되지 않은 응답이 모두 지워질 수 있다.

**우아하게 커넥션 끊기**

일반적으로 애플리케이션이 우아한 커넥션 끊기를 구현하는 것은 애플리케이션 자신의 출력 채널을 먼저 끊고 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것이다.

물론 상대방이 절반 끊기를 구현했다는 보장이나 절반 끊기를 했는지 검사한다는 보장도 없다. 따라서 애플리케이션은 출력 채널에 절반 끊기를 한 이후에도 입력 채널에 대한 상태 검사를 주기적으로 해야한다. 만약 입력 채널이 특정 시간 내에 끊어지지 않으면, 애플리케이션은 커넥션을 강제로 끊을 수도 있다.
