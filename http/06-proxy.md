# 6. 프록시

프록시는 클라이언트와 서버 사이에 위치하여 HTTP 메시지를 정리하는 중개인처럼 동작한다.

## 6.1 웹 중개자

웹 프록시 서버는 클라이언트 입장에서 트랜잭션을 수행하는 중개인이다. 클라이언트는 HTTP 서버 대신 프록시와 대화하며 프록시 서버가 제공하는 기능들을 이용하게 된다.

HTTP 프록시 서버는 웹 서버이면서 동시에 웹 클라이언트이다. 따라서 서버처럼 요청과 커넥션을 적절히 다루고, 클라이언트처럼 요청을 보내고 받을 수 있어야한다.

### 6.1.1 개인 프록시와 공유 프록시

- 개인 프록시: 하나의 클라이언트만을 위한 프록시
- 공유 프록시: 여러 클라이언트를 위한 프록시
  - 대부분 프록시가 이에 속한다.
  - 캐시 프록시 등 몇몇 프록시는 여러 사용자들의 공통 요청에서 이득을 취할 수 있기에 사용자가 많을 수록 유리하다.

### 6.1.2 프록시 대 게이트웨이

- 프록시: 같은 프로토콜을 사용하는 둘 이상 애플리케이션 연결
- 게이트웨이: 서로 다른 프로토콜을 사용하는 둘 이상 애플리케이션 연결 (프로토콜 변환기처럼 동작)

실질적으로는 프록시가 일부 프로토콜 변환도 수행하기 때문에 나누는게 모호하다.

## 6.2 왜 프록시를 사용하는가?

보안 개선, 성능 증가, 비용 절약, 트래픽 감시 및 수정

**기능 예시**

- 컨텐츠 필터링
- 중앙화된 접근 제어
- 방화벽: 응용 레벨 프로토콜을 한 지점에서 통제
- 웹 캐시: Hit가 많은 문서의 로컬 사본 관리, NW 커뮤니케이션 비용 감소
- 대리(리버스) 프록시
- 콘텐츠 라우터: 요청을 특정 웹 서버로 유도
- 트랜스코더: 클라이언트 전달 전 콘텐츠 본문 포맷을 수정
- 익명화 프록시: HTTP 메시지에서 개인 정보 항목을 수정/제거

## 6.3 프록시는 어디에 있는가?

### 6.3.1 프록시 서버 배치

프록시는 어디에든 배치될 수 있다.

**Egress (출구) 프록시**

로컬 네트워크 ↔ 인터넷 간의 트래픽을 제어하기 위해 **로컬 네트워크의 출구**에 놓는 프록시, 방화벽, 트래픽 성능 개선, 콘텐츠 필터링 등에 사용

**ISP 접근 프록시 → ISP: 인터넷 공급자?**

**ISP 접근 지점에 위치**한 프록시, 케시 프록시 등을 사용해 다운로드 속도 개선 / 대역폭 비용 감소

**리버스 (대리) 프록시**

**웹 서버의 바로 앞**에서 웹 서버로 향하는 모든 요청을 처리, 필요할 때만 웹 서버에 자원 요청

**네트워크 교환 프록시**

혼잡 완화 및 트래픽 흐름 감시를 위해 네트워크 사이 **인터넷 피어링 교환 지점**에 놓인 프록시

### 6.3.2 프록시 계층

프록시는 프록시 계층이라 불리는 연쇄를 구성할 수 있다.

- 다음번 인바운드(서버 방향) 프록시: 부모
- 다음번 아웃바운드(클라이언트 방향) 프록시: 자식

**프록세 계층 콘텐츠 라우팅**

계층이 반드시 정적이어야 하는 것은 아니다. 프록시는 여러 가지 판단 근거에 의해 메시지를 다양한 프록시 서버나 원 서버 집합으로 보낼 수 있다.

동적 선택의 기준 예시 → 부하 / 지리적 인접성 / 프로토콜(또는 타입) 등

### 6.3.3 어떻게 프록시가 트래픽을 처리하는가

클라이언트 트래픽이 프록시로 가도록 만드는 방법에는 다음 네 가지가 있다.

1. 클라이언트를 수정

   브라우저의 경우 수동, 자동 프록시 설정을 지원한다.

2. 네트워크를 수정

   스위치나 라우팅 장치를 통해 HTTP 트래픽을 프록시로 보낼 수 있다. 이를 인터셉트 프록시라고 한다.

3. DNS Namespace 수정

   리버스 프록시는 웹 서버의 이름과 IP 주소를 직접 사용한다. 따라서 요청이 프록시로 오게된다. 이는 DNS 네임테이블을 직접 수정하거나 동적 DNS 서버 등을 통해 조정될 수 있다.

4. 웹 서버를 수정

   HTTP 리다이렉션 코드를 반환하여 클라이언트가 요청을 프록시로 리다이렉트 하도록 한다.

## 6.4 클라이언트에 프록시 설정

많은 브라우저가 프록시를 설정할 여러 방법을 제공한다.

- 수동 설정: 명시적 설정
- 브라우저 기본 설정: 벤더나 배포자가 미리 설정
- 프록시 자동 설정(PAC): 프록시 자동 설정 파일에 대한 URI를 제공, 클라이언트는 해당 파일을 가져와 판단
- WPAD 프록시 발견: 자동설정 파일을 다운받을 수 있는 설정 서버를 자동으로 찾아주는 프로토콜 제공

### 6.4.2 클라이언트 프록시 설정: PAC

수동 프록시 설정은 모든 콘텐츠를 위해 단 하나의 프록시 서버만 지정할 수 있고, 장애 시 대체 작동에 대한 지원도 없는 등 유연하지 못하다.

PAC 파일은 프록시 설정을 그때그때 계산해 주는 동적인 해결책이다.

### 6.4.3 클라이언트 프록시 설정: WPAD

WPAD는 브라우저에 알맞은 PAC 파일을 자동으로 찾아주는 알고리즘이다. WPAD가 구현된 클라이언트는 PAC 파일을 자동으로 찾고, 설정하는 일을 하게된다.

WPAD는 올바른 PAC 파일을 알아내기 위해 일련의 리소스 발견 기법을 순서대로 시도한다.

## 6.5 프록시 요청의 미묘한 특징들

### 6.5.1 프록시 URI는 서버 URI와 다르다

클라이언트가 프록시 대신 서버로 요청을 보내면 요청의 URI가 달라진다.

**클라이언트 → 웹 서버**

```
GET /index.html HTTP/1.0
User-Agent: SuperBrowserv1.3
```

**클라이언트 → 프록시**

```
GET http://www.marys.com/index.html HTTP/1.0
User-Agent: SuperBrowserv1.3
```

기존 HTTP 설계에서 클라이언트는 자신의 호스트명, 포트번호를 알고 있는 단일 서버와 직접 대화했고, 불필요한 정보 발송을 피하기 위해 클라이언트는 이런 정보를 제외한 URI만 보냈다.

그러나 후에 생긴 프록시는 목적지 서버와의 커넥션 및 여러 스킴 연결을 위해 이 정보들을 필요로 했고, 프록시 요청에 한해 완전한 URI를 요구하는 것으로 문제를 해결했다.

- 클라이언트는 명시적으로 설정된 프록시에는 완전한 URI를 보낸다.

### 6.5.2 가상 호스팅에서 일어나는 같은 문제

가상으로 호스팅되는 웹 서버에 부분 URI 요청이 오면, 가상으로 호스팅되는 웹 서버는 요청이 접근하고자 하는 웹 사이트의 호스트명을 알 필요가 있다. 따라서 가상으로 호스팅되는 웹 서버는 호스트와 포트에 대한 정보가 담겨있는 Host 헤더를 요구한다.

### 6.5.3 인터셉트 프록시는 부분 URI를 받는다

클라이언트가 프록시 사용을 설정하지 않더라도, 트래픽은 여전히 대리 프록시나 인터셉트 프록시를 지날 수 있다. 이 때 클라이언트는 완전한 URI를 보내지 않을 것이다.

### 6.5.4 프록시는 프록시 요청과 서버 요청을 모두 다룰 수 있다

트래픽이 프록시 서버로 리다이렉트 될 여러 방법이 존재하기 때문에, 다목적 프록시 서버는 완전한 URI와 부분 URI를 모두 지원해야 한다.

사용 규칙

- 완전한 URI → 그대로 사용
- 부분 URI + Host 헤더 → Host 헤더로 원 서버의 이름 + 포트 탐색
- 부분 URI → 원 서버를 알아낸다.

### 6.5.5 전송 중 URI 변경

무해해 보이는 변경도 상호운용성 문제를 일으킬 수 있다. 프록시는 가능한 관대해야한다. 특히 HTTP 명세는 인터셉트 프록시가 URI를 전달할 때 절대 경로를 고쳐 쓰는 것을 금지한다. (빈 경로를 ‘/’로 교체하는 것은 예외)

### 6.5.6 URI 클라이언트 자동확장과 호스트명 분석

브라우저는 프록시 존재 여부에 따라 요청 URI를 다르게 분석한다. 프록시가 없다면 사용자가 타이핑한 URI를 가지고 대응 IP를 찾으며, 호스트가 발견되지 않으면 자동화된 호스트명의 확장을 제공하려고 시도한다.

### 6.5.7 프록시 없는 URI 분석

다음은 프록시 없는 브라우저의 호스트 명 자동 확장 과정이다.

1. 요청 호스트명을 이용, http + 80포트 + 기본 경로(/)로 간주
2. 호스트를 못 찾는 경우 DNS로 www.호스트명.com 을 주소분해 요청
3. 반환된 IP 주소들에 대해 접속 시도

### 6.5.8 명시적인 프록시를 사용할 때의 URI 분석

명시적인 프록시를 사용한다면 위의 브라우저 자동확장 기능들은 이용할 수 없다. 때문에 몇몇 프록시는 지역 도메인 접미사 추가 등 브라우저의 편리한 서비스를 최대한 흉내내려고 시도한다.

### 6.5.9 인터셉트 프록시를 이용한 URI 분석

인터셉트 프록시가 서버에 대한 장애 처리도 해주어야 한다.

## 6.6 메시지 추적

프록시가 흔해지면서 프록시를 넘나드는 메시지 흐름을 추적하고 문제점을 찾아내는 것도 필요한 일이 되었다.

### 6.6.1 Via 헤더

메시지가 지나는 각 중간 노드의 정보를 나타낸다. 중간 노드를 지날 때마다 해당 노드는 Via 목록의 끝에 반드시 추가되어야 한다.

`Via: 1.1 proxy-62.hello-isp.net, 1.0 cache.joes-hard.com`

사용처

- 요청-응답 과정에 관여하는 메시지 발송자들의 프로토콜 다루는 능력 확인
- 네트워크 라우팅 루프 탐지
  - 프록시는 요청을 보내기 전 자기 자신을 가리키는 유니크한 문자열을 삽입한다. 그리고 들어온 요청에 이 문자열이 있는지 검사한다.

**Via 문법**

Via의 항목들은 waypoint라고 불린다. 이는 다음으로 구성된다. (**볼드**는 필수값)

1. 프로토콜 이름: 중개자가 받은 프로토콜, 기본 HTTP
2. **버전: 수신한 메시지 버전, 포맷은 프로토콜 마다 다르다**
3. **노드 이름: 중개자의 호스트+포트 번호, 가명으로 대체 가능**
4. 노드 코멘트: 벤더나 버전 정보, 진단 정보 등 추가적인 정보

**Via 요청과 응답 경로**

요청 메시지와 응답 메시지 모두 프록시를 지나므로 둘 모두 Via 헤더를 갖는다. 응답의 Via 경로는 거의 항상 요청 경로의 반대다.

**Via와 게이트웨이**

몇몇 프록시는 서버에게 비 HTTP 프로토콜을 사용할 수 있는 게이트웨이 기능을 제공한다. Via 헤더는 이런 프로토콜 변환을 기록하므로 애플리케이션은 프록시 연쇄를 통해 프로노콜 변환 능력을 검증할 수 있다.

**Server 헤더와 Via 헤더**

Server 응답 헤더 필드는 원 서버에 의해 사용되는 SW를 알려준다.

`Server: Apache/1.3.14 (Unix) PHP/4.0.4`

**Via가 개인정보 보호와 보안에 미치는 영향**

- 프록시는 보안상의 이유로 Via 노드 이름(호스트)을 가명으로 교체할 수 있다.
- 여러 경유지들이 모두 같은 조직 통제하에 있는 경우 Via 경유지 항목을 하나로 합칠 수 있다.

### 6.6.2 TRACE 메서드

프록시 서버는 메시지가 전달될 때 메시지를 바꿀 수 있다. 특히 복잡한 프록시는 상호 운용성 문제가 증가시킨다. HTTP의 TRACE 메서드는 프록시 연쇄를 따라가며 각 프록시가 요청 메시지를 어떻게 수정하는지 관찰/추적할 수 있도록 해준다.

TRACE 요청이 목적지 서버에 도착하면, 서버는 **전체 요청 메시지 그대로**를 HTTP 응답 본문에 포함시켜 송신자에게 돌려보내며 클라이언트는 이를 검사한다.

**Max-Forwards**

일반적인 TRACE 메시지는 중간 프록시의 갯수를 신경쓰지 않고, 모든 path를 이행한다. TRACE 요청의 hop 갯수를 조정하기 위해서는 이 헤더를 사용할 수 있는데, 이는 무한루프 테스트 특정 프록시 검증 등에 사용할 수 있다.

- 반드시 정수, 0인 경우 받자마자 TRACE 응답 반환
- 수신 프록시는 전달될 메시지의 Max-Forwards 필드 값을 1씩 감소시킨다.

## 6.7 프록시 인증

프록시는 HTTP 사용자가 유효한 접근 권한을 프록시에 제출하지 않는 경우 콘텐츠 요청을 차단하는 프록시 인증 메커니즘을 정의한다.

## 6.8 프록시 상호운용성

프록시 서버는 여러 벤더에 의해 만들어지며 지원하는 HTTP 버전도, 기능도 제각각인 상황에서 클라이언트와 서버 사이을 중개해야 한다.

### 6.8.1 지원하지 않는 헤더와 메서드 다루기

- 지원하지 않는 헤더일지라도 그대로 전달한다.
- 동일한 이름의 헤더 필드가 여러 개인 경우 상대적 순서를 반드시 유지한다.
- 메서드를 해석하지 못하는 경우에도 가능한 다음 홉으로 메시지를 전달한다.

### 6.8.2 OPTIONS: 어떤 기능을 지원하는지 알아보기

OPTIONS 메서드는 는 서버 / 서버의 리소스가 어떤 기능을 지원하는지 알아볼 수 있게 해준다.

### 6.8.3 Allow 헤더

Allow 헤더 필드는 요청 URI에 의해 식별되는 자원(URI가 \*인 경우에는 서버)에 대해 지원되는 메서드들을 열거한다. 이는 요청 헤더로도 사용될 수 있는데, 이 경우 필드는 새 리소스가 지원해줬으면 하는 메서드를 추천하기 위해 사용된다.
