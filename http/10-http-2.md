# 10. HTTP/2.0

## 10.1 등장 배경

HTTP/1.1은 단순성을 주안점으로 두었다. 커넥션 하나로 요청/응답을 주고받는 구조는 성능을 어느정도 희생할 수 밖에 없었다. 대표적인 예시는 바로 응답을 받기 전 다음 요청을 보낼 수 없는 회전 지연이다.

## 10.2 개요

- HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다.
- 요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담긴다.
- 프레임은 스트림을 통해 보내지며, 한 개의 스트림은 한 쌍의 요청/응답을 처리한다.
- 하나의 커넥션 위에 여러 스트림이 동시에 만들어질 수 있다.
- 스트림에 대한 흐름 제어, 우선 순위 부여, 서버 푸시 등의 기능을 제공한다.

## 10.3 HTTP/1.1과의 차이점

### 10.3.1 프레임

2.0에서는 모든 메시지가 프레임에 담겨 전송된다. 모든 프레임은 8바이트 크기의 헤더로 시작하며, 최대 16383 크기의 페이로드가 온다.

### 10.3.2 스트림과 멀티플렉싱

스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 양방향 시퀸스다. HTTP/2.0에서는 하나의 커넥션으로 여러 스트림을 열어서 동시에 여러 요청을 보낼 수 있게 되었다.

서버와 클라이언트는 스트림을 상대와의 협상 없이 일방적으로 만들 수 있다. 그리고 이는 핸드셰이킹에 대한 시간 낭비를 줄인다.

커넥션에서 한 번 사용한 스트림 식별자는 다시 사용할 수 없다. 때문에 스트림에 할당할 식별자가 고갈되기도 하는데, 그런 경우엔 커넥션을 다시 맺으면 된다.

### 10.3.3 헤더 압축

헤더의 크기는 회전 지연과 대역폭에 실질적인 영향을 준다. 이를 개선하기 위해 2.0에서는 헤더를 압축하여 전송한다. 압축에 사용되는 HPACK 명세는 압축과 해제 시 압축 콘텍스트를 사용한다. 따라서 오동작을 방지하려면 항상 올바른 압축 콘텍스트를 유지해야 한다.

### 10.3.4 서버 푸시

서버는 하나의 클라이언트 요청에 대해 여러 리소스를 응답으로 보낼 수 있다. 이는 회전 지연 및 트래픽을 줄여준다.

- 서버는 클라이언트에게 리소스를 푸시할 것이라는 `PUSH_PROMISE` 프레임 전송
  - 클라이언트가 자원을 별도로 요청하는 상황을 미리 방지
- 클라이언트가 `PUSH_PROMISE`을 받게 되면 해당 프레임의 스트림은 예약상태가 됨
- 이 상태에서 푸시를 거절하려면 `RST_STREAM`을 보내며 이 경우 스트림은 즉각 닫힘

## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐화 공격

HTTP/2.0은 헤더 필드로 어떤 문자열이든 사용할 수 있다. 이는 정상적인 요청이나 응답이 위조된 1.1 메시지로 번역되는 상황을 유발할 수 있다.

### 10.4.2 긴 커넥션 유지로 인한 개인정보 유출

길게 유지되는 커넥션은 개인정보 유출에 악용될 우려가 있다.
