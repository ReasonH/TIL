# 14. 보안 HTTP

## 14.1 HTTP를 안전하게 만들기

웹은 안전한 방식의 HTTP를 필요로 한다. HTTP의 보안 버전은 다음 조건을 충족해야 한다.

- ex) 서버/클라 인증, 무결성, 암호화, 효율, 호환성, 확장성, 적응성

## 14.2 디지털 암호학

생략

## 14.3 대칭 키 암호법

인코딩과 디코딩에 같은 키를 사용, 노드들은 통신하려는 대상의 수만큼 공개키를 갖고 있어야 한다. 이렇게 되면 대칭키의 쌍이 매우 많아질 수 있다.

## 14.4 공개키 암호법

노드 A가 자신의 공개키 E를 배포, A와 통신하려는 노드들은 E를 사용해 인코딩, 디코딩은 E에 대응되는 개인키를 가진 노드 A만 가능하다.

- 이는 클라이언트가 메시지를 쉽게 암호화하여 목적지에 보낼 수 있게 해준다.
- 보안 프로토콜을 전 세계 모든 사용자에게 적용 가능하게 했다.

### 14.4.1 RSA

RSA알고리즘은 공개키 비대칭 암호 체계이다.

1. 공개키
2. 암호문의 일부
3. 메시지 + 인코더를 통해 얻은 암호문

이 알고리즘은 위의 3가지를 알고 있더라도 개인 키를 계산할 수 없도록 한다.

### 14.4.2 혼성 암호 체계와 세션 키

공개키 암호 방식 알고리즘은 계산이 느린 경향이 있다. 따라서 노드들 간의 채널 수립 시에만 공개 키 암호를 사용하고, 안전한 채널을 통해 대칭 키를 생성 및 교환하여 이후의 데이터 암호화에는 대칭 키를 사용하는 방식이 흔히 쓰인다.

## 14.5 디지털 서명

누가 메시지를 썼는지 알려주고, 그 메시지가 위조되지 않았음을 증명하기 위해 사용하는 기법

1. 발신자는 메시지 + 메시지 요약과 개인키를 이용해 만든 서명 전송
2. 수신자는 공개키를 이용해 서명을 검사
   - 수신자가 받은 메시지 평문 요약과 역 암호화된 서명(메시지 요약)이 일치하지 않으면 위/변조 등 문제가 있는 것으로 판단

## 14.6 디지털 인증서

인증서는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있다.

### 14.6.1 인증서의 내부

인증서에는 공식적으로 ‘인증 기관’에 의해 디지털 서명된 정보의 집합이 담겨있다.

**포함 정보**

- 인증서 포맷 버전 / 일련번호 / 서명 알고리즘 / 발행자 / 유효 기간
- 대상의 이름 / 공개키 etc
- 위 정보들을 이용한 디지털 서명

### 14.6.2 X.509 v3 인증서

오늘날 사용되는 대부분의 인증서는 그들의 정보를 X.509라는 표준화된 서식에 저장하고 있다.

### 14.6.3 서버 인증을 위해 인증서 사용하기

사용자가 HTTPS를 통한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다. 서버가 인증서를 갖고 있지 않다면, 보안 커넥션은 실패한다.

브라우저가 인증서의 서명기관을 검사했을 때, 신뢰할만한 기관이라면 브라우저는 공개키를 이미 알고 있을 것이다. 이 경우 서명 검증 프로세스가 진행된다.

서명 기관이 알 수 없는 곳이라면, 사용자에게 서명 기관을 신뢰하는지 확인한다.

## 14.7 HTTPS 세부사항

HTTPS는 HTTP 프로노콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다. 이는 분산된 웹 애플리케이션에서의 보안 관리에 있어 대단히 중요하다.

### 14.7.1 HTTPS 개요

- HTTPS는 보안 전송 계층을 통해 전송되는 HTTP이다.
- HTTP를 TCP로 보내기 전, 이를 암호화하는 보안 계층으로 보낸다.
- 보안 계층은 SSL/TLS를 통해 구현된다.

클라이언트와 서버가 HTTPS 처리를 위해 프로토콜 처리 로직을 수정할 필요는 없다. 단지 보안 정보를 설정하고 관리하기 위한 몇 가지 호출을 추가하기만 하면 된다.

### 14.7.2 HTTPS 스킴

URL이 https 스킴을 갖고 있다면 클라이언트는 기본적으로 서버 443 포트로 연결하며 서버와 바이너리 포맷으로 된 SSL 보안 매개변수들을 교환하며 핸드셰이크한다.

### 14.7.3 보안 전송 셋업

1. 클라이언트는 웹 서버의 443포트로 연결
2. TCP 연결 이후 암호 매개변수 및 교환 키 협상하며 SSL 핸드셰이킹 → SSL 초기화
3. 완료 후, 클라이언트는 요청 메시지를 보안 계층에 전송, 이는 TCP 전송 전 암호화됨

### 14.7.4 SSL 핸드셰이크

SSL 핸드셰이크에서는 다음 작업을 수행한다.

- 프로토콜 버전 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원 인증
- 채널 암호화를 위한 임시 세션 키 생성

SSL은 통신을 시작하기 위해 많은 핸드셰이크 데이터를 주고받는다. 이는 보다 복잡해질 수 있다.

### 14.7.5 서버 인증서

HTTPS 트랜잭션은 항상 서버 인증서를 요구한다. 서버 인증서는 조직 이름, 주소, 도메인 이름 등의 정보를 보여주는 X.509 v3에서 파생된 인증서이다. 클라이언트는 신뢰성을 확인하기 위해 이 인증서를 검증할 수 있다.

### 14.7.6 사이트 인증서 검사

SSL 자체는 사용자에게 웹 서버 인증서 검증을 요구하지 않지, 최신 웹브라우저 대부분은 인증서에 대해 기본적인 검사를 하고 그 결과를 사용자에게 알려준다.

수행 단계는 다음과 같다.

1. 날짜 검사
2. 서명자 신뢰도 검사
3. 서명 검사
4. 사이트 신원 검사: 인증서 도메인 이름과 대화 중인 도메인 서버의 이름 일치 검사

### 14.7.7 가상 호스팅과 인증서

몇몇 웹 서버 프로그램은 하나의 인증서만 지원한다. 사용자가 인증서의 이름과 정확히 맞지 않는 가상 호스트에 도착했다면 경고가 나타날 것이다. 가상 호스팅 사이트의 이증서 관리는 까다로울 수 있다.

## 14.8 진짜 HTTPS 클라이언트

몇 가지 SSL 클라이언트와 서버 프로그래밍을 쉽게 만들어주는 라이브러리들이 있다.

OepnSSL은 가장 인기 있는 SSL / TLS 오픈소스 구현체이다. 구현은 생략한다.

## 14.9 프록시를 통한 보안 트래픽 터널링

클라이언트가 서버로 보낼 데이터를 서버 공개키로 암호화 하기 시작했다면, 프록시는 더 이상 HTTP 헤더를 읽을 수 없고, 요청을 어디로 보내야 하는지도 알 수 없게 된다.

HTTPS SSL 터널링 프로토콜을 사용하면 HTTPS 클라이언트가 프록시에게 접속 목적지를 말해주는 방법을 수정할 수 있다. 이 프로토콜을 사용하는 클라이언트는 먼저 프록시에게 자신이 연결하고자 하는 호스트와 포트를 평문으로 말해준다(HTTP의 CONNECT 확장 메서드 사용). 연결이 완료되면, 클라이언트와 서버 사이에는 데이터가 직접 오갈 수 있는 터널이 만들어진다.
