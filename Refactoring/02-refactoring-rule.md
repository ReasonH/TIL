# 리팩터링 원칙

### 2.1 리팩터링 정의

코드를 정리하는 작업 ≠ 리팩터링이다. 리팩터링은 동작을 보존하는 작은 단계를 거쳐 코드를 수정하고 이런 작업을 연결해 큰 변화를 만드는 일이다. 따라서 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업 종료 전에 언제든 멈출 수 있다. 코드베이스를 정리하거나 구조를 바꾸는 모든 작업은 재구성(restructing)이며 리팩터링은 재구성 중 특수한 한 형태이다.

1. 리팩터링 전과 후의 코드는 똑같이 동작해야 한다.

    이 과정에서 함수 콜스택은 변할 수 있지만, 사용자 관점에서는 달라지는 점이 없어야 한다.

2. 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 남아있어야 한다.

리팩터링의 결과로 성능은 좋아질 수도 나빠질 수도 있다.

### 2.2 두 개의 모자

기능 추가와 리팩터링은 명확하게 분리되어야 한다.

기능 추가 - 기존 코드를 절대 건드리지 않고 새 기능을 추가하기만 한다.

리팩터링 - 기능 추가는 절대 하지 않고 오로지 코드 재구성에만 전념한다. 테스트도 새로 만들지 않으며 인터페이스 변경이 필요할 때만 기존 테스트를 수정한다.

둘의 작업 차이를 인지하는 것이 중요하다.

### 2.3 리팩터링하는 이유

**소프트웨어 설계가 좋아진다**

규칙적인 리팩터링은 코드의 구조를 지탱해준다. 설계가 나쁘면 같은 일을 하는 코드가 여러 곳에 나타나고 코드가 길어지게 된다. 코드가 길어지면 실수 없이 수정하는 것을 어려워지고 이해해야 할 코드량도 늘어난다. 또한, 한 부분만 바꿔서는 시스템이 예상한대로 동작하지 않을 수 있다.

중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있다.

**소프트웨어를 이해하기 쉬워진다.**

프로그래밍에서는 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 한다. 코드를 컴파일하는데 오래걸리는 것보다 누군가가 내 코드를 읽고 이해하는데 오래걸리는게 더 큰일이다.

프로그램을 동작시키는 데만 신경쓰다 보면 그 코드를 다룰 개발자를 배려하지 못하게 된다. 리팩터링은 코드가 더 잘 읽히게 도와주고, 코드의 목적(내 의도)를 더 명확하게 전달하도록 개선할 수 있다.

꼭 다른 개발자를 위해서가 아니라 나 자신을 위해서라도 기억할 것들은 코드에 담아야 하며 이를 위해 리팩터링이 필요하다.

**버그를 쉽게 찾을 수 있다.**

프로그램의 구조를 다듬다보면 가정하던 부분이 명확히 드러나고, 버그가 명확해진다. 리팩터링은 견고한 코드를 작성하기 위한 효과적인 방법이다.

**프로그래밍 속도를 높일 수 있다.**

한 시스템을 오래 개발할 수록 새로운 기능 추가에는 더 오랜 시간이 걸리는 경우가 있다. 기존 코드베이스에 녹여낼 방법을 찾아야 하고, 새로운 기능이 버그를 불러오고, 해결하는 데 시간이 걸리는 등 기능 추가에 대한 부담이 속도를 떨어뜨리기 때문이다.

소프트웨어의 내부 품질이 좋다면?

-   새로운 기능을 추가할 지점과 고칠 부분을 쉽게 찾을 수 있다.
-   모듈화가 잘 되어 있다면 전체 코드베이스 중 일부만 이해하면 된다.
-   버그를 만들 가능성을 줄이고, 만들더라도 디버깅을 쉽게 만든다.

즉 내부 설계에 심혈을 기울이면 소프트웨어를 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다. 처음부터 좋은 설계를 만들기는 매우 어렵기 때문에 빠른 개발을 위해서는 리팩터링이 필수이다.

### 2.4 언제 리팩터링해야 할까?

**준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**

리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 이 시점에 코드를 살펴보며 구조를 바꿈으로써 다른 작업이 쉬워질만한 부분을 찾는다. _ex) 함수 매개변수화 하기_

버그를 잡을때도 마찬가지다. 오류를 일으키는 코드가 세 곳에 복제되어 있다면 한 곳으로 합치는 편이 작업하기 훨씬 편하다. 준비를 위한 리팩터링으로 코드를 개선하면 버그가 수정된 상태로 오래 지속될 수 있도록하는 동시에, 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수 있다.

**이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**

코드를 수정하려면 그 코드가 하는 일을 파악해야 한다. 따라서 코드를 파악할 때는 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지가 없는지 찾아본다.

**쓰레기 줍기 리팩터링**

코드를 파악하는 중 비효율적인 부분을 발견하게 된다면

-   간단한 작업이면 즉시 고친다.
-   시간이 걸리면 짧은 메모만 남기고 하던 일을 끝낸 뒤 처리한다.

보이는 부분을 조금씩이라도 개선하다보면 문제가 해결된다.

**계획된 리팩터링과 수시로 하는 리팩터링**

앞의 세가지 리팩터링은 기회가 될 때만 진행한다. 기능을 추가할 때든 버그를 잡을 때든, 리팩터링은 앞으로 할 작업에 도움을 준다. 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니므로 일정을 따로 잡지 않고, 다른 일을 하는 중에 처리한다.

소프트웨어 개발은 끝이 있는 작업이 아니다. 새 기능이 필요할 때마다 소프트웨어는 수정되는데, 이때 새로 작성하는 코드보다 기존 코드의 수정량이 많은 경우가 대체로 많다.

<aside>
💡 저자의 의견:
계획된 리팩터링은 필요할 수 있지만, 최소한으로 줄여고 기회가 될 때마다 해야한다.
버전 관리 시스템에서 리팩터링 커밋과 기능 추가 커밋은 분리하지 않아야 한다. 리팩터링을 하게 된 맥락이 사라질 수 있기 때문이다.

</aside>

**오래 걸리는 리팩터링**

종종 있는 대규모 리팩터링에서 팀 전체가 리팩터링에 메달리기보다는, 각자가 대상 코드와 관련된 작업을 할 때마다 조금씩 원하는 방향으로 개선하는게 효과적일 때가 많다.

예를 들어 라이브러리 교체에서는 기존 코드와 새 코드를 모두 포용하는 추상 인터페이스부터 마련한다. 기존 코드가 이 인터페이스를 호출하도록 만들면 라이브러리를 훨씬 쉽게 교체할 수 있다.

**코드 리뷰에 리팩터링 활용하기**

코드 리뷰는 시스템의 다양한 측면을 더 많은 사람이 이해할 수 있도록 돕는다. 다른 팀원의 눈을 통해 깔끔한 코드를 작성할 수 있도록 돕고, 다른 사람의 아이디어를 얻게 해준다.

리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데 도움된다. 개선안을 제시하는 데 그치지 않고 상당수를 즉시 구현해볼 수 있기 때문이다. 이를 위해서는 페어 프로그래밍을 활용할 수 있다.

**관리자에게는 뭐라고 할까?**

리팩터링한다고 말하지 말라. 프로에게 주어진 임무는 빠르게 새로운 기능을 구현하는 것이고, 그를 위한 가장 빠른 방법은 리팩터링이다. 그래서 리팩터링부터 한다.

**리팩터링하지 말아야 할 때**

-   외부 API처럼 호출해서 쓰는 코드는 그냥 사용한다. 코드를 이해해야 할 시점에 리팩터링 해야 효과가 있다.
-   처음부터 새로 작성하는게 쉬울 때도 리팩터링하지 않는다.

### 2.5 리팩터링 시 고려할 문제

**새 기능 개발속도 저하**

리팩터링의 궁극적 목표는 개발 속도를 높이는 것이다. 리팩터링의 동력은 경제적인 효과이다.

**코드 소유권**

리팩터링하다 보면 모듈 내부 뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많다. 이 때 코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 예를들어 함수 이름을 변경할 때는 클라이언트에 영향을 주지 않기 위해 새로운 함수 본문에서 기존 함수를 호출하는 등 복잡한 인터페이스를 만들게 된다.

대규모 시스템 개발 시에는 코드 소유권을 느슨하게 하여 필요한 사항을 코드베이스에서 곧바로 수정할 수 있도록 하는게 좋다.

**브랜치**

기능별 브랜치의 마스터 통합 주기는 짧게 관리한다. 이렇게 하면 브랜치 간 차이가 적어져 머지 복잡도를 낮출 수 있기 때문이다. 특히, CI는 리팩터링과 궁합이 잘 맞는다.

**테스팅**

리팩터링의 두드러진 특성은 프로그램의 동작이 똑같이 유지된다는 것이다. 핵심은 실수로 동작이 깨지더라도 오류를 재빨리 잡는 데 있다. 이를 위해서는 자가 테스트 코드를 마련해야 한다.

자가 테스트가 있다면

-   리팩터링을 도우며 새 기능 추가를 안전하게 진행할 수 있도록 도와준다.
-   리팩터링 과정에서 생길 버그에 대한 불안감을 해소할 수 있다.

자가 테스트 코드는 통합 과정에서 발생하는 충돌을 잡는 메커니즘으로 활용할 수 있어서 CI와도 밀접히 연관된다.

**레거시 코드**

레거시 코드 파악에는 리팩터링이 도움이 된다. 그러나 테스트 코드가 없이 이를 명료하게 하기란 어렵다.

이를 해결하기 위한 방법은 당연히 테스트 보강이다. 레거시 코드를 테스트하기란 쉽지 않지만, 책에서 조언하는 한 가지 방법은 ‘프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다’는 것이다. 위험하긴 해도 리팩터링으로 틈새를 먼저 만들고 이를 테스트하도록 한다.

테스트를 갖추고 있더라도 단번에 리팩토링 하는 것은 어렵다. 서로 관련된 부분을 하나 씩 공략한다. 특히, 자주 보는 부분일수록 더 많이 리팩토링한다.

**데이터베이스**

DB리팩터링에서는 커다란 변경들을 쉽게 조합하고 다룰 수 있는 마이그레이션 스크립트를 작성하고, 접근 코드와 DB스키마에 대한 구조 변경을 이 스크립트로 처리하게끔 통합한다.

이는 다른 리팩터링과 다르게 프로덕션 환경에 여러 단계로 나눠서 릴리즈하는 것이 좋다. 이렇게 하면 문제가 생겼을 때 번경을 되돌리기 쉽다.

### 2.6 리팩터링, 아키텍쳐, 애그니(You are not going to need it)

코딩 전에 아키텍처를 확정지으려 할 때의 문제는 소프트웨어 요구사항을 사전에 모두 파악해야 한다는 것이다. 그러나 우리는 소프트웨어를 실제로 사용해보고 나서야 원하는 바를 알게 되는 경우가 많다.

한 가지 방법은 향후 변경에 유연하게 대처할 수 있는 유연성 메커니즘을 소프트웨어에 심어두는 것이다. 가령 다양한 예상 시나리오에 대응하기 위한 매개변수를 추가하는 작업이 그 예시이다. 하지만 유연성 메커니즘은 함수를 복잡하게 만들고, 잘못 구현되는 경우 변화에 대응하는 능력을 떨어뜨린다.

리팩터링을 활용하면 다르게 접근할 수 있다. 우선은 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. 사용자의 요구사항을 이해하게 되는 순간 그에 맞게 아키텍쳐도 리팩토링 하는 것이다. 그 과정에서 복잡도에 지장을 주지 않는 유연성 메커니즘(ex, 함수 네이밍)은 마음껏 추가하지만, 복잡도를 높이는 유연성 메커니즘은 반드시 검증 이후에 추가한다.

### 2.7 리팩터링과 소프트웨어 개발 프로세스

자가 테스트 코드, 지속적 통합, 리팩터링은 서로 강력한 상승효과를 발휘한다.

위의 세 실천법을 적용한다면 앞서 설명한 애그니 설계 방식으로 개발을 진행할 수 있다.

### 2.8 리팩터링과 성능

리팩터링하면 성능이 느려질 수 있는 건 사실이다. 하지만 그와 동시에 성능 튜닝은 더 쉬워진다.

빠른 소프트웨어를 작성하는 세 가지 방법

1. 시간 예산 분배 방식
    - 설계를 여러 컴포넌트로 나누고 자원을 할당
    - 엄격한 시간 엄수, 데이터가 늦게 도착하면 안되는 경우 중요
2. 끊임없는 관심

    높은 성능을 유지하기 위해 무슨 일이든 한다. 그러나 이는 프로그램 특정 동작에만 관련될 뿐, 컴파일러와 런타임, 하드웨어의 동작을 이해하지 못한 채 작성할 때도 많다.

    <aside>
    💡 시스템에 대해 잘 알더라도 섣불리 추측하지 말고, 성능을 측정해봐야 한다.

    </aside>

    프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다. 따라서 전체 코드를 고르게 최적화하면 그 중 90%는 효과가 거의 없다.

3. **의도적으로 성능 최적화에 돌입하기 전 에는 코드를 다루기 쉽게 만드는데 집중**

    - 프로그램을 분석하여 시간과 공간을 많이 잡는 지점 파악
    - 작은 단계로 나눠서 최적화 수행

    이때 프로그램이 잘 리팩터링 되어 있다면 성능 튜닝에 투입할 시간을 벌 수 있고, 성능을 더 세밀하게 분석할 수 있다.
