# 캡슐화

모듈 분리의 가장 중요한 기준은 아마도 시스템에서 각 모듈이 자신을 제외한 다른 부분에 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐에 있을 것이다.

### 7.1 레코드 캡슐화하기

레코드 구조는 연관된 여러 데이터를 묶을 수 있어서 의미있는 단위를 만들 수 있지만, 계산해서 얻을 수 있는 값과 그렇지 않은 값을 구분해서 저장해야하는 점이 번거롭다. 가변 데이터를 저장하는 용도로 객체를 사용하는 경우 저장 과정을 숨긴 채 다양한 가변 값을 각각의 메서드로 제공할 수 있다. 레코드를 캡슐화하는 목적은 변수 자체는 물론 그 내용을 조작하는 방식도 통제하기 위함이다.

레코드 구조는 두 가지로 구분할 수 있다.

1. 필드 이름을 노출하는 형태
2. 필드를 외부로부터 숨기는 형태 - ex) 해시맵, 딕셔너리

2의 경우 필드를 명확히 알려주지 않는다는 게 단점이 될 수 있다. 이를 리팩토링 하는 경우 레코드 대신 클래스를 사용하는 편이 낫다.

**절차**

```jsx
const orgnization = { name: "이유혁", country: "KR" };
```

1. 레코드를 담은 변수를 캡슐화 → 레코드 변수를 반환하는 함수 생성

    ```jsx
    function getRawDataOfOrganization() {
        return organization;
    }
    ```

2. 레코드를 감싼 단순 클래스로 변수 내용을 교체

    1. 클래스에 원본 레코드를 반환하는 접근자를 정의
    2. 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정

    ```jsx
    class Organization {
        constructor(data) {
            this._data = data;
        }
    }

    const orgnization = new Organization({ name: "이유혁", country: "KR" });
    function getRawDataOfOrganization() {
        return organization._data;
    }
    ```

3. 테스트
4. 원본 레코드 대신, 새로 정의한 클래스 타입 객체를 반환하는 함수를 새로 만든다.

    ```jsx
    function getOrganization() {
        return organization;
    }
    ```

5. 레코드를 반환하는 예전 함수를 사용하는 코드를 4의 함수를 사용하도록 변경한다. 필드 접근 시 객체의 접근자를 사용한다.

    1. 갱신코드 수정

        ```jsx
        // class 수정
        set name(aString) {this._data.name = aString;}

        // client 수정
        getOrganization().name = newName;
        ```

    2. 읽기코드 수정

        ```jsx
        // class 수정
        get name() {return this._data.name;}

        // client 수정
        result += `<h1>${getOrganization().name}</h1>`
        ```

6. 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 제거한다.

    ```jsx
    ~~function getRawDataOfOrganization() {return organization};~~
    ```

7. 테스트
8. 가능하다면 내부 데이터의 필드들을 객체 안에 바로 펼쳐놓는다.

    ```jsx
    class Organization {
        constructor(data) {
            this.name = data.name;
            this.country = data.country;
        }
        // 기타 getter, setter 등
    }
    ```

레코드를 참조하여 캡슐화를 깰 우려가 있는 코드가 많을 때 이렇게 하면 입력 데이터 레코드와 객체 간의 연결을 끊어준다는 이점이 생긴다. (ex. getter 사용 시, data를 통해 field를 참조하는 기존 방식은 위험함)

JSON구조 등 중첩이 많은 레코드를 리팩터링할 때는?

**쓰기**

중첩 정도가 심할수록 데이터 구조 안으로 더 깊숙히 들어가야 한다. 기본적인 절차는 위와 같지만 getter를 호출 후 중첩되어있는 값을 갱신하는 경우에 주의해야 한다.

⇒ 데이터 구조 안으로 들어가서 갱신하는 코드는 setter로 뽑아낸다.

캡슐화에서는 값을 수정하는 부분을 명확히 드러내고 한 곳에 모아두는 일이 굉장히 중요하다.

**읽기**

읽기에 대한 처리 방법도 다양하다.

-   읽는 코드를 모두 독립함수로 추출
    -   장: 명시적 API 제공, 단: 읽는 패턴이 다양할 수록 작성 코드 증가
-   클라이언트가 데이터 구조를 요청할 때 내부 데이터를 복제해서 제공
    -   장: 간단함, 단: 복제 비용, 클라이언트가 원본을 수정한다고 착각할 여지 있음
    -   해결: 읽기 전용 프락시를 제공해서 복제본 동결 → 데이터 수정 시 에러 던지도록 만들 수 있음

### 7.2 컬렉션 캡슐화

컬렉션 변수로의 접근을 캡슐화하면서 getter가 컬렉션 자체를 반환하도록 한다면, 컬렉션을 감싼 클래스가 눈치채지 못하는 상태에서 컬렉션 원소들이 바뀌어버릴 수 있다. 이를 방지하기 위해 컬렉션을 감싼 클래스에 변경자 메서드를 만들 수 있다.

이는 원본 모듈 밖에서 컬렉션을 수정하는 것을 원천적으로 막을 수 없다. 따라서 추가적으로 **getter가 컬렉션 자체를 반환하지 않게 만든다.**

가장 흔히 사용되는 방식은 컬렉션 getter를 제공하되 내부 컬렉션의 복제본을 반환하는 것이다.

<aside>
💡 코드베이스의 일관성을 위해 컬렉션 접근함수의 동작 방식은 하나로 통일해야 한다.

</aside>

**절차**

1. 컬렉션을 캡슐화
2. 컬렉션에 원소 추가/제거 함수 추가
3. 정적 검사
4. 컬렉션을 참조하는 부분을 모두 찾아서 변경자를 호출하는 코드가 2의 추가/제거 함수를 호출하도록 수정
5. 컬렉션 getter를 수정해서 원본 내용을 수정할 수 없는 복제본을 반환하게 한다.
6. 테스트

컬렉션에 대해서는 불필요한 복제본을 만드는 편이, 예상치 못한 수정이 촉발한 오류를 디버깅하는 것보다 낫다.

### 7.3 기본형을 객체로 바꾸기

개발 초기에는 단순한 정보를 숫자나 문자열로 표현했더라도 이런 정보는 개발이 진행되면서 복잡해진다.

ex) 문자열로 전화번호 표현 → 포맷팅, 지역코드 추출 등의 로직 추가 → 중복 코드 증가 → 공수 증가

단순 출력 이상의 기능이 필요해지는 순간 그 데이터를 표현하는 전용 클래스를 정의하면 매우 유용하다.

**절차**

```jsx
class Order {
    constructor(data) {
        this.priority = data.priority;
    }
}
```

1. 변수를 캡슐화

    ```jsx
    class Order {
        constructor(data) {
            this.priority = data.priority;
        }
        get priority() {
            return this._priority;
        }
        set priority(aString) {
            this._priority = aString;
        }
    }
    ```

2. 단순한 값 클래스 생성, 기존 인수를 받아서 저장하고 이를 반환하는 getter 추가

    ```jsx
    class Priority {
        constructor(value) {
            this._value = value;
        }
        toString() {
            return this._value;
        }
    }
    ```

3. 정적 검사
4. 값 클래스 인스턴스를 만들어서 저장하도록 1의 setter 수정
5. 새로 만든 클래스의 getter 호출 결과를 반환하도록 1의 getter 수정

    ```jsx
    class Order {
        constructor(data) {
            this.priority = data.priority;
        }
        get priorityString() {
            return this._priority.toString();
        }
        set priority(aString) {
            this._priority = new Priority(aString);
        }
    }
    ```

6. 테스트
7. 함수 이름 변경 검토

이것만으로도 리팩터링은 끝냈지만, Priority를 그 자체로 의미있게 하기 위해 다양한 메서드를 추가해서 사용할 수도 있다. 이렇게 하면 클라이언트 코드를 더 의미있게 작성할 수 있다.

```jsx
// 예시, Priority 클래스에 higherThan 메서드 추가한 경우 클라이언트 코드
highPriorityCount = orders.filter((o) => o.priority.higherThan(new Priority("normal"))).length;
```

### 7.4 임시 변수를 질의 함수로 바꾸기

임시 변수를 사용하면 값을 계산하는 코드가 반복되는 걸 줄이고 값의 의미를 설명할 수 있어서 유용하다. 한 걸음 더 나아가 아예 함수로 만들어서 사용하는 편이 더 나을때도 많다.

1. 긴 함수의 한 부분을 별도 함수로 추출할 때 변수들을 각각의 함수로 만들면 일이 수월하다.
    - 추출한 함수에 변수를 전달 필요가 없음
    - 추출한 함수와 원래 함수의 경계가 더 분명해짐 → 부자연스러운 의존 관계, 부수효과 제거에 도움
2. 변수 대신 함수로 만들어두면 코드 중복이 줄어든다.

클래스는 공유 컨텍스트를 제공하기 때문에 이를 적용할 때 효과가 가장 크다.

<aside>
💡 임시 변수를 질의함수로 바꾼다고 다 좋아지는건 아니다.
스냅샷 용도로 사용하는 임시 변수에는 이 리팩터링을 적용하면 안된다.
⇒ 값이 항상 동일하지 않은 경우에는 X

</aside>

**절차**

```jsx
var basePrice = this._quantity * this._item.price;
```

1. 변수가 사용되기 전에 값이 확실히 결정되는지, 변수를 사용할 때마다 계산 로직이 매번 다른 결과를 내지 않는지 확인한다.
2. 읽기 전용으로 만들 수 있는 변수는 읽기 전용으로 만든다.

    ```jsx
    const basePrice = this._quantity * this._item.price;
    ```

3. 테스트
4. 변수 대입문을 함수로 추출한다.

    ```jsx
    const basePrice = this.basePrice;

    get basePrice() {
    	return this._quantity * this._item.price;
    }
    ```

5. 테스트
6. 변수 인라인하기로 임시 변수를 제거한다.

    ```jsx
    this.basePrice; // 직접사용
    ```

### 7.5 클래스 추출하기

클래스는 명확하게 추상화된 주어진 소수의 역할만 처리해야한다. 그러나 실무에서는 다양한 데이터와 연산을 추가하며 클래스가 점점 비대해진다.

-   **일부 데이터와 메서드를 따로 묶을 수 있다면 분리의 신호이다.**
-   함께 변경되는 일이 많거나 서로 의존하는 데이터들도 분리한다.

**특정 데이터나 메서드 일부를 제거해도 다른 필드나 메서드들이 논리적으로 문제가 없다면 분리할 수 있다는 뜻**이다. 또한, 일부의 기능만을 위한 서브클래스를 추가하거나, 확장 기능에 따른 서브클래스 생성 방식이 달라진다면 클래스를 나눠야 한다.

**절차**

1. 클래스 역할 분리 방법을 정한다.
2. 분리 역할을 담당할 클래스를 새로 만든다.
3. 원래 클래스 생성자에서 새로운 클래스 인스턴스를 생성하여 필드에 저장한다.
4. 분리된 역할에 필요한 필드들을 새 클래스로 옮긴다(필드 옮기기) → 옮길때마다 테스트
5. 메서드들도 새 클래스로 옮긴다. 호출을 당하는 일이 많은 메서드를 우선으로 옮긴다. → 옮길때마다 테스트
6. 양쪽의 인터페이스를 살펴보며 불필요 메서드를 제거하고, 이름도 바꾼다.
7. 새 클래스를 외부로 노출할 지 정한다. 새 클래스에 참조를 값으로 바꾸기를 적용할지 고민해본다.

| 이번 장에서 가장 유의마하다고 생각한다. 클래스 추출에 대한 명확한 기준을 안내하고 있으며 절차 또한 리팩터링 도구만으로 해결할 수 없는 부분을 보완하고 있다.

### 7.6 클래스 인라인

특정 클래스에 역할이 거의 없는 경우 이를 가장 많이 사용하는 클래스로 흡수시킨다. 두 클래스의 기능을 다르게 배분하고 싶을 때도 클래스를 인라인해서 합친 후 새로운 클래스로 추출한다.

**절차**

소스 클래스 A, 타깃 클래스 B

1. A의 public 메서드에 대응하는 메서드들을 B에 생성한다.
    - B의 메서드들은 단순히 A의 public 메서드를 호출한다.
2. A의 메서드를 사용하는 코드들을 새로 생성한 B의 메서드로 대체한다. → 하나마다 테스트
3. A의 메서드와 필드를 모두 B로 옮긴다. → 하나마다 테스트
4. 소스 삭제

### 7.7 위임 숨기기 (↔ 중개자 제거하기)

캡슐화는 모듈들이 시스템의 다른 부분에 대해 알아야 할 내용을 줄여준다. 이는 변경 시 고려해야 할 모듈 수를 줄여서 코드 변경을 쉽게 만들어준다.

**캡슐화 ≠ 필드를 숨기는 것**

서버 객체의 필드가 가리키는 객체의 메서드를 호출하려면 클라이언트는 이 위임 객체의 인터페이스를 알아야 한다.

ex) 사원 클래스의 부서 필드 참조, 부서 객체로부터 관리자를 조회하는 케이스
⇒ 클라이언트는 부서 클래스가 관리자 정보를 제공한다는 사실을 알아야 한다.

이 때 위임 객체 인터페이스가 변경되면 이를 사용하는 모든 클라이언트가 코드를 수정해야 한다. 이런 의존성을 없애려면 서버 자체에 위임 메서드를 만들어서 위임 객체의 존재를 숨기면 된다.

**절차**

1. 위임 객체의 각 메서드에 해당하는 위임 메서드를 서버에 생성
2. 클라이언트가 위임 객체 대신 서버 메서드 호출하도록 수정
3. 모두 수정 시, 서버로부터 위임 객체를 얻는 접근자 제거
4. 테스트

### 7.8 중개자 제거하기 (↔ 위임 숨기기)

위임 숨기기를 사용하는 경우, 클라이언트가 위임 객체의 또 다른 기능을 사용하고 싶을 때마다 서버에 위임 메서드를 추가해야 한다. 이렇게 기능을 추가하는 경우 서버 클래스가 단순히 중개자 역할로 전락하여, 클라이언트가 위임 객체를 직접 호출하는 게 나을 수 있다.

위임 숨기기와 중개자 제거하기 중 어느게 적절한지 판한다기는 쉽지 않다. 때에 따라 적절하게 응용할 뿐이다.

**절차**

1. 위임 객체를 얻는 getter를 만든다.
2. 위임 메서드를 호출하는 클라이언트가 모두 getter를 거치도록 수정한다.
3. 모두 수정 후 위임 메서드를 삭제한다.

7.7과 7.8은 적당히 섞어서 상황에 맞게 사용할 수 있다.

### 7.9 알고리즘 교체하기

때로는 알고리즘 전체를 걷어내고 간결한 알고리즘으로 바꿔야 할 때가 있다. 알고리즘을 살짝 다르게 동작하도록 바꾸고 싶을 때도 변화를 더 쉽게 가할 수 있는 알고리즘으로 바꾼 후 처리하면 편할 수 있다.

<aside>
💡 작업 전에 반드시 메서드를 가능한 잘게 나눴는지 확인한다.

</aside>

**절차**

1. 교체할 코드를 함수를 하나에 모은다.
2. 함수만을 이용해 동작을 검증하는 테스트를 마련한다.
3. 대체 알고리즘을 준비한다.
4. 정적 검사
5. 기존 알고리즘 - 새 알고리즘 결과를 비교하는 테스트를 수행
