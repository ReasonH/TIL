# 기본적인 리팩터링

### 6.1 함수 추출하기

코드를 언제 독립된 함수로 묶어야 할까?

1. 길이 - ex) 한 함수가 화면을 넘어가지 않아야 한다.
2. 재사용성 - ex) 두 번 이상 사용되면 함수로 만든다.
3. 목적과 구현을 분리하기 위해서
    - 코드를 보고 무슨 일을 하는지 파악하는 데 한참 걸리는 경우? → 추출해서 작업을 표현하는 이름을 붙임

필자의 의견으로는 함수의 길이는 중요하지 않다. (단 한 줄이어도, 심지어 이름이 내용보다 길어도 상관없다.)

코드의 목적과 구현 사이의 차이가 클 수록 함수 추출이 의미있어진다.

> what과 how의 괴리감이 클 때, 분리할 것

> 이름이 떠오르지 않으면? 추출하지 말라는 신호

**절차**

1. 무엇을 하는지가 드러나도록 함수 이름 작성
    - 대상 코드가 간단해도 목적이 잘 드러나는 적절한 이름이 있다면 함수로 뽑아낸다.
        - 이름이 떠오르지 않으면 추출하면 안 된다는 신호다.
2. 추출할 코드를 원본으로부터 복사해온다.
3. 함수 유효범위를 벗어나는 변수가 있는지 검사한다.
    - 추출한 코드에서 사용은 하지만 함수에서 값이 바뀌지 않으면 인수로 전달한다.
    - 추출한 코드에서만 사용하는 변수는 함수 내부로 가져온다.
    - 추출한 코드에서 값을 바꾸는 변수는?
        - 이런 변수가 하나라면 질의함수처럼 취급
        - 이런 변수가 너무 많다면 추출을 멈추고 변수 쪼개기 / 임시 변수를 질의 함수로 변경하기 등으로 다른 리팩터링 먼저 적용
4. 컴파일
5. 원본 함수의 대상 코드를 추출한 함수로 대체
6. 테스트
7. 다른 코드에 똑같거나 비슷한 코드가 있다면 함수 호출로 변경 검토

**함수에서 반환해야 할 변수가 여러개인 경우에 대해**

-   값 하나만 반환하는 함수 여러개로 분리
-   꼭 한 함수에서 여러 값을 반환해야 한다면 레코드로 묶어서 반환

### 6.2 함수 인라인하기

가끔은 함수 본문이 이름만큼 명확하거나, 본문 코드를 이름만큼 깔끔하게 리팩터링 하는 경우가 있다. 이럴 때는 그 함수를 제거한다.

-   간접 호출은 유용하지만, 쓸데 없는 간접 호출은 거슬린다.
-   간접 호출이 너무 과한 경우도 문제다. 위임 관계가 너무 복잡하면 인라인한다.

**절차**

1. 다형 메서드 여부 확인
2. 함수 호출부를 모두 찾는다.
3. 각 호출을 본문으로 교체
4. 교체마다 테스트
5. 함수 삭제

호출을 본문으로 교체할 때는 단순히 복사 붙여넣기로 안 되는 경우가 많다. 이 때는 단계를 잘게 나눠서 테스트를 병행한다.

> 많이 겪은 적 없음

### 6.3 변수 추출하기

표현식이 너무 복잡해서 이해하기 어려운 경우 변수를 활용할 수 있다.

-   로직 구성 단계마다 이름을 붙임으로써 목적을 명확히 할 수 있음
-   디버깅에 중단점을 지정할 수 있음

대상이 현재 함수에서만 의미가 있다면 변수로 추출하지만, 함수를 벗어난 넓은 문맥에서 의미가 있다면 해당 범위에서도 통용되는 이름을 생각해야 한다. 즉 변수가 아닌 함수로 추출해서 이름이 통용되는 문맥을 넓히도록 한다.

**절차**

1. 추출 대상 표현식의 부작용 확인
2. 불변 변수에 표현식 복제본 대입
3. 원본 표현식을 교체
4. 테스트
5. 표현식 사용 부분 모두 교체 - 테스트 반복

객체는 특정 로직과 데이터를 외부와 공유하려 할 때 공유할 정보를 설명하는 적당한 크기의 문맥이 되어준다. 덩치가 큰 클래스에서 공통 동작을 별도 이름으로 뽑아서 (함수로) 추상화해두면 객체를 다루기가 더 쉬워진다.

### 6.4 변수 인라인하기

변수가 원래 표현식과 다를 바 없거나, 주변 코드를 리팩터링하는데 방해된다면 인라인한다.

**절차**

1. 표현식의 부작용 확인
2. 변수가 불변이 아니라면 먼저 불변으로 만들고 테스트
    - 값 대입이 한 번인지 확인하는 절차
3. 변수를 가장 처음 사용하는 코드를 찾아서 변경
4. 테스트
5. 다음 변수들을 찾으며 변경 - 테스트 반복
6. 변수 선언문과 대입문을 삭제
7. 테스트

### 6.5 함수 선언 바꾸기

함수 선언은 프로그램 각 부분이 맞물리는 방식을 표현하며, 시스템 구성 요소를 조립하는 연결부 역할을 한다. 이를 잘 정의하면 시스템에 새로운 부분을 추가하기가 쉬워진다.

함수 이름은 연결부에서 가장 중요한 요소이다. 이름이 잘못된 함수를 발견하면 더 나은 이름이 떠오르는 즉시 변경한다.

<aside>
💡 주석을 사용해 함수의 설명을 적다보면 좋은 이름이 떠오르기도 한다.

</aside>

매개변수도 마찬가지다. 매개변수는 함수가 외부와 어우러지는 방식을 정의한다.

ex) 전화번호 포맷팅 함수가 매개변수로 사람을 받으면? → 회사 전화번호는 포맷팅 할 수 없음

매개변수를 적절히 지정하면 함수 활용 범위가 넓어지며, 다른 모듈과의 결합을 제거할 수 있다. 동작에 필요한 모듈이 적어지면 수정 또한 쉬워진다.

매개변수 선택은 단순히 규칙 몇 개로 표현할 수 없다.

ex) 매개변수가 객체를 받으면 함수의 캡슐화 수준이 높아지지만, 객체의 여러 속성에 접근하게 되서 내부 로직은 복잡해진다.

이 문제의 정답은 없다. 더 잘 이해하게 될 때마다 코드를 개선할 수 있도록 리팩터링과 친해져야 한다.

**간단한 절차**

1. 매개변수를 제거하려면 본문에서 매개변수 참조를 확인
2. 메서드 선언을 원하는 형태로 변경
3. 기존 메서드 선언 참조를 모두 수정
4. 테스트

이름 변경과 매개변수 추가를 모두 하고 싶다면 각각 독립적으로 처리한다. 그러다가도 문제가 생기는 경우에는 호출을 점진적으로 수정하기 위해 다음의 마이그레이션 절차를 따른다.

**마이그레이션 절차**

1. 함수의 본문을 적절히 리팩터링
2. 함수 본문을 새로운 함수로 추출 → 기존 함수에서는 새로운 함수를 호출
3. 추출한 함수에 매개변수 추가가 필요하다면 위의 ‘간단한 절차'에 따라 추가
4. 테스트
5. 기존 함수 호출부에서 새로운 함수 호출하도록 변경
6. 새로운 함수를 원래 함수 이름으로 변경
7. 테스트

-   상속 구조에 있는 클래스 메서드 변경 → 간접 호출 방식으로 우회하는 방법 사용
-   공개된 API 리팩터링 → 새 함수 추가 이후 클라이언트가 새 함수로 이전할 때까지 대기 후 삭제

### 6.6 변수 캡슐화하기

함수는 데이터보다 다루기가 수월하다. 반대로 데이터는 함수보다 다루기가 까다롭다. 데이터는 참조하는 모든 부분을 바꿔야 코드가 제대로 작동한다. 유효범위가 넓어질 수록 다루기는 더 어려워진다.

따라서 접근 범위가 넓은 데이터를 옮길 때는 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 좋은 방법일 때가 많다. 필자는 유효범위가 함수 하나보다 넓은 데이터는 모두 캡슐화한다고 한다.

불변 데이터는 가변 데이터보다 캡슐화할 이유가 적다. 검증 로직도 필요 없으며 옮길 때는 복제만 하면 된다.

**절차**

1. 변수로의 접근을 전담하는 캡슐화 함수 생성
2. 정적 검사
3. 변수 직접 참조를 모두 함수 호출로 변경 (변경마다 테스트)
4. 변수 접근 범위 제한
5. 테스트
6. 변수 값이 레코드라면 → 레코드 캡슐화 고려

캡슐화를 통해 데이터 구조(Object)로의 참조를 캡슐화하면, 구조로의 접근이나 구조 자체 대입 행위는 제어할 수 있지만, 필드 값을 변경하는 일은 제어할 수 없다.

```kotlin
let obj = {foo: "foo", bar: "bar"};
export function getObj() {return obj;}
export function setObj(newObj) {obj = newObj}
```

변수뿐 아니라 변수에 담긴 내용을 변경하는 행위까지 캡슐하하고 싶은 경우에는 값을 바꿀 수 없게 만든다.

-   게터가 데이터 복사본을 반환하도록 수정
-   혹은 아예 변경할 수 없도록 게터에서 데이터를 레코드(객체)로 캡슐화

데이터 캡슐화는 과정이 간단하지 않을 때가 많다. 또한, 캡슐화의 대상과 방법은 데이터 사용 방식, 변경하려는 방식에 따라 달라진다.

### 6.7 변수 이름 바꾸기

함수 호출 한 번으로 끝나지 않고(람다식처럼), 값이 영속되는 필드라면 이름에 더 신경 써야 한다.

**절차**

1. 변수가 폭넓게 쓰이면 변수 캡슐화 고려
2. 이름을 바꿀 변수를 참조하는 곳을 모두 찾아 하나씩 변경
3. 테스트

### 6.8 매개변수 객체 만들기

데이터 항목 여러 개가 몰려다닌다면 데이터 뭉치를 구조로 묶는다. 이 경우

-   데이터 사이의 관계가 명확해짐
-   함수의 매개변수가 줄어듦
-   같은 데이터 구조를 사용하는 함수들이 동일한 이름으로 구조를 사용하기 때문에 일관성 확보

등의 이점을 얻을 수 있다.

더 나아가 데이터 구조는 코드를 근본적으로 바꿔줄 수 있다. 데이터 구조를 만들고 나서 데이터에 공통으로 적용되는 동작은 함수로 만들어냄으로써 동작을 재구성 할 수 있다. 이는 데이터 구조를 추상 개념으로 격상시키고, 코드를 다시 그릴 수 있게 한다.

**절차**

1. 데이터 구조 생성 (단순 obj보다 클래스가 좋다. JAVA는 default가 class)
2. 테스트
3. 새 데이터 구조를 추가로 사용하도록 함수 선언 바꾸기
4. 테스트
5. 함수 호출 시 새로운 구조 인스턴스를 넘기도록 수정 (테스트)
6. 기존 매개변수를 사용하던 코드를 데이터 구조를 사용하도록 변경
7. 매개변수 재거 후 테스트

위에서 말했듯 데이터 구조는 코드를 근본적으로 바꿀 수 있다. 단순히 매개변수의 형태를 변경하고 끝나는 것이 아니라 해당 데이터 구조와 관련된 동작을 옮기면서 코드베이스 전반에서 데이터 객체를 사용하는 방식으로 간소화가 가능하다.

> 매개변수를 묶을 때, 모듈 내에서 통용되면 OK, 단순 함수간에 공통으로 사용되고 X

### 6.9 여러 함수를 클래스로 묶기

클래스는 함수들이 공유하는 환경을 명확하게 표현하고, 함수 간 전달되는 인수를 줄여 객체 안에서의 함수 호출을 간결하게 만들 수 있다. 이는 만들어진 함수 재구성은 물론 새로 만든 클래스에서 놓친 연산을 찾아서 메서드로 뽑아내는 데도 좋다.

클래스로 묶을 때의 두드러진 장점은 클라이언트가 객체의 핵심 데이터를 변경할 수 있고, 파생 객체들을 일관되게 관리할 수 있다는 점이다.

**절차**

1. 함수들이 사용하는 공통 데이터 레코드를 캡슐화 (클래스화)
2. 공통 레코드를 사용하는 함수들을 새 클래스로 옮김
3. 데이터를 조작하는 로직은 함수로 추출해서 새 클래스로 옮김

-   파생 데이터는 필요한 시점에 계산되게하여 데이터 갱신에 대해 안전하게 만든다.
-   프로그램의 다른 부분에서 데이터를 갱신할 가능성이 있을 때, 클래스로 묶어두면 큰 도움이 된다.

### 6.10 여러 함수를 변환 함수로 묶기

데이터를 입력받아 도출하는 작업을 한데로 모아두면 검색과 갱신을 일관된 장소에서 처리할 수 있고 중복 로직도 막을 수 있다. 이를 위한 방법으로 변환 함수를 사용할 수 있다.

변환 함수 vs 클래스로 묶기

-   **원본 데이터가 코드 안에서 갱신되는 경우 변환함수 결과의 일관성이 깨질 수 있음**

**절차**

1. 변환할 레코드를 입력받아 값을 그대로 (복사해서) 반환하는 변환 함수 생성
2. 묶을 함수 중 하나를 골라서 본문 코드를 변환 함수로 옮기고, 처리 결과를 새 필드에 기록
3. 테스트
4. 나머지 함수도 위와 같이 처리

예시로 특정 레코드를 입력받고, 다양한 파생 정보를 계산하는 로직을 변환 함수 하나로 모을 수 있다. 변환 단계에서 미가공 측정값을 입력받아 다양한 가공 정보를 **필드에 덧붙여** 반환하는 것이다.

변환 함수에서는 결과 객체를 마음껏 변경해도 된다. 다만 클라이언트가 데이터를 변경하는 경우에 일관성이 깨진다.

### 6.11 단계 쪼개기

서로 다른 대상을 다루는 코드를 모듈로 나누게 된다면 코드 수정이 필요할 때 하나의 대상에만 집중할 수 있게된다. 이를 위한 가장 간편한 방법은 연이은 동작을 두 단계로 쪼개는 것이다. ex) 컴파일러의 컴파일 과정

다른 단계로 볼 수 있는 코드 영역들이 서로 다른 데이터와 함수를 사용한다면 단계 쪼개기에 적합하다는 뜻이다. 코드 영역을 모듈로 분리하면 이런 차이를 분명하게 드러낼 수 있다.

**절차**

1. 두 번째 단계에 해당하는 코드를 독립 함수로 추출
2. 테스트
3. 중간 데이터 구조를 만들어 추출한 함수의 인수로 추가
4. 테스트
5. 추출한 함수 매개변수를 검토, **첫 번째 단계에 사용되는 것**은 중간 데이터 구조로 이동
6. 첫 번째 단계 코드를 함수로 추출하며 중간 데이터 구조를 반환하도록 만든다.

JAVA의 경우 이 단계에서 예시가 두 개이다.

단순히 필드만 갖춘 데이터 레코드를 만드는 방식과 각종 함수까지 포함하고 있는 변환기 객체를 만드는 방식이다. 정답은 정해지지 않았기 때문에 취향껏 사용한다.
