# 악취

다음 나올 내용들은 대표적인 리팩토링 대상 사례들이다.

### 3.1 기이한 이름

이름만 보고도 무슨일을 하는지 어떻게 사용해야 하는지 알 수 있어야 한다. 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어있을 가능성이 높다.

> 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어있을 가능성이 높다.

### 3.2 중복 코드

똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

-   한 클래스의 두 메서드 표현식이 동일한 경우 → 함수 추출하기
-   코드가 비슷하지만 완전히 같지는 않은 경우 → 문장 슬라이스하기
-   서브클래스 간의 코드가 중복된 경우 → 메서드 올리기

### 3.3 긴 함수 (V)

함수를 짧게 할 수록 코드의 이해, 공유, 선택이 쉬워진다. 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다. 원래 코드보다 길어지더라도 함수로 뽑으며 이름에 코드의 목적을 드러내야 한다.

코드가 단 한줄이어도 설명할 필요가 있다면 함수로 추출하는게 좋다.

-   조건문 → 조건문 분해하기
-   switch-case → 함수 추출하기, 조건부 로직 다형성으로 바꾸기
-   반복문 코드에 적합한 함수명이 떠오르지 않는다면 → 반복문 쪼개기

> switch-case에 대해서 인터페이스로 뽑는건 OK인데, 공수비용이 너무 많이들지 않나.. 어느정도는 허용하는게 좋지 않을까?

### 3.4 긴 매개변수 목록 (V)

매개변수가 많은 경우 매개변수를 질의 함수로 바꾸기, **객체 통째로 넘기기, 매개변수 객체 만들기, 플래그 인수 제거하기** 등을 사용한다. 여러 함수가 특정 매개변수 값을 공통으로 사용해야 하는 경우 **여러 함수를 클래스로 묶기**를 이용한다.

> 무조건 객체로 묶는게 좋을까? 객체의 위치가 어디에 속하는지에 대한 고민이 있더라

### 3.5 전역 데이터

전역 데이터는 가장 주의해야 한다. 전역 데이터의 대표적 형태는 전역 변수 뿐만 아니라 클래스와 싱글톤에서도 동일하다. 이를 방지하기 위한 방법은 **변수 캡슐화**하기다.

전역 데이터가 가변인 경우 더욱 문제가 커진다.

### 3.6 가변 데이터

-   정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 변경
-   용도별 독립 변수 생성
-   갱신하는 로직은 부작용이 없는 코드로부터 분리
-   필요한 경우가 아니라면 부작용이 있는 코드 호출을 금지
-   세터를 제거하여 변수의 유효범위를 줄이기
-   파생 변수는 질의 함수로 변경
-   변수를 갱신하는 코드들의 유효범위를 클래스, 변환으로 제한
-   내부 필드 직접 수정 대신 구조체를 통째로 교체

### 3.7 뒤엉킨 변경

SRP가 지켜지지 않아 소프트웨어를 변경하기 힘들어진 상태를 말한다.

각 맥락에 해당하는 모듈을 만들어 관련 함수를 모아서 처리 과정을 구분한다.

> 모듈이 변경되어야 하는 이유는 하나이다. SRP 위배는 이런 법칙을 위배한다.

### 3.8 산탄총 수술

코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많은 경우를 말한다. 이럴 때는 함께 변경되는 대상들을 한 모듈에 묶으면 좋다.

비슷한 데이터를 다루는 함수가 많은 경우 → 여러 함수를 클래스로 묶기

비슷한 데이터 구조를 변환하거나 보강하는 함수인 경우 → 여러 함수를 변환 함수로 묶기

묶은 함수들의 출력 결과를 묶어서 다음 단계로 전달할 수 있다면 → 단계 쪼개기

어설프게 분리된 로직 → 함수 인라인, 클래스 인라인

> 중복 코드에 대한 이야기이다.

### 3.9 기능 편애

_프로그램 모듈화에서는 코드를 영역으로 구분한다. 영역 내 상호작용은 최대로, 영역 사이의 상호작용은 최소로 한다._

기능 편애는 특정 함수가 자기가 속한 모듈보다 다른 모듈과 상호작용이 많은 상태를 뜻한다.

-   해당 함수로를 해당 데이터, 모듈 근처로 옮긴다.
-   함수의 일부만 기능편애가 있는 경우, 해당 부분만 함수 추출 후 모듈 근처로 옮긴다.

어디로 옮길지가 명확하게 드러나지 않는 경우 (ex, 함수가 사용하는 모듈이 다양)는 어떻게 할까?

-   가장 많은 데이터를 포함한 모듈로 이동
-   함수를 여러 조각으로 나누고 각각 적합한 모듈로 이동

> Tip. 설계할 때 어떤 메세지를 주고 받을 지를 위주로 고민하면, 책임이 손쉽게 분리될 수 있다.
> 즉 객체가 가져야 할 상태를 생각하는 단계는 되도록 뒤로 미루자.

### 3.10 데이터 뭉치

-   필드 형태의 데이터 뭉치는 하나의 객체로 묶는다.
-   시그니처에 있는 데이터 뭉치는 매개변수 객체로 묶거나 객체 통째로 넘기기를 사용한다.

데이터 뭉치인지 판별하는 법: 값 하나를 삭제했을 때 나머지 데이터만으로 의미가 없는 경우

### 3.11 기본형 집착

원시적인 기본형들을 유의미하고, 일관된 동작을 하는 객체로 바꾼다.

### 3.12 반복되는 switch문 (V)

중복된 switch문들이 반복해 등장하면 꼭 다형성이 필요하다.

### 3.13 반복문

일급 함수를 통해 반복문을 파이프라인으로 변경함으로써 처리 과정을 쉽게 파악할 수 있다.

> 과연 스트림이 정답인가?
> hong: 스트림은 개인의 코드 스타일이 과하게 나타나는데, 이게 오히려 단점일 수도 있다.
> lee: 스트림으로 처리할 수 없는 비즈니스 로직들도 분명 있다. 만능이 아님

### 3.14 성의 없는 요소 (V)

메서드가 하나 뿐인 클래스, 의미없는 함수와 같이 그 구조가 필요없는 경우는 고이 보내주자.

함수 인라인, 클래스 인라인, 계층 합치기 등을 적용해 삭제할 수 있다.

### 3.15 추측성 일반화

당장 필요없는 로직들을 작성해서 이해, 관리가 어려워진 코드는 삭제한다.

하는 일이 없는 추상 클래스 → 계층 합치기

쓸데없는 위임 코드 → 함수 인라인, 클래스 인라인

사용되지 않는 매개변수 → 함수 선언 바꾸기

> 일단 현재 필요한 로직에 집중

### 3.16 임시 필드 (V)

특정 상황에서만 값이 설정되는 필드를 가진 클래스는 코드 이해를 어렵게 만든다. 이 때는

1. 클래스 추출하기로 임시 필드의 살 곳을 만들기
2. 임시 필드들과 관련된 코드를 모조리 새 클래스에 넣기
3. 임시 필드를 통해 동작하는 조건부 로직을 특이 케이스 추가하기로 처리

### 3.17 메시지 체인

이는 클라이언트가 한 객체를 통해 다른 객체를 얻고, 그 객체로 다른 객체를 요청하는 연쇄 작업이 이어지는 코드를 말한다.

이 때는 메세지 체인의 다양한 연결점에 최종 객체를 얻어오는 위임 코드를 작성하는 **위임 숨기기**를 통해 문제를 해결할 수 있다. (중간 객체들이 모두 중개자가 되는 상황은 피해야 한다.)

### 3.18 중개자

클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 실제로 일을 하는 객체와 소통하게 만든다. 위임 메서드 제거 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자

### 3.19 내부자 거래

모듈 간 불투명한 상호작용을 없앤다. 여러 모듈이 같은 관심사를 공유한다면 중간자 역할을 하는 다른 모듈을 만든다. 무분별한 결속을 없애는 것은 상속 구조에서도 동일하다.

### 3.20 거대한 클래스

클래스 필드가 너무 많아지면 클래스 추출하기로 유사한 필드들 일부를 따로 묶는다.

클래스 코드가 너무 많아지면 중복 코드들을 최대한 잘게 쪼갠다.

> **클라이언트들이 어떻게 이용하는지 패턴을 파악하면 거대 클래스를 개별 클래스로 쪼갤 단서를 얻을 수 있다. ⇒ 관점을 바꿔라**

### 3.21 서로 다른 인터페이스의 대안 클래스들

당연한 소리임

### 3.22 데이터 클래스

데이터 클래스는 필드와 getter/setter로만 구성된 클래스이다. public 필드가 있다면 레코드 캡슐화하기로 숨긴다. 다른 클래스에서 데이터 클래스의 게터 세터를 사용하는 메서드를 데이터 클래스로 옮기는 것도 방법이다.

-   중간 데이터 구조의 불편 필드는 굳이 캡슐화할 필요가 없다.

> 그냥 되도록이면 데이터클래스를 쓰지말자. Setter를 지양하자 제발

### 3.23 상속 포기

서브클래스가 부모 클래스의 데이터와 메서드 중 일부만 관심있는 경우이다.

이 때는 서브클래스/슈퍼클래스를 위임으로 바꾸기를 통해 상속 메커니즘에서 벗어나보자.

### 3.24 주석

> 주석을 남겨야겠다면 가장 먼저 주석이 필요없는 코드로 리팩터링해본다.

주석을 남겨야 할 때

-   뭘 할지 모를 때
-   확실하지 않은 부분
-   코드를 지금처럼 작성한 이유
