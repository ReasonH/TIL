# 데이터 조직화

하나의 값이 여러 목적으로 사용되면 혼란과 버그를 낳는다.

### 9.1 변수 쪼개기

긴 코드의 결과를 저장했다가 나중에 쉽게 참조하려는 목적으로 사용되는 변수는 값을 단 한 번만 대입해야 한다. **대입이 두 번 이상 이뤄진다는 것**은 역할이 둘 이상이라는 의미이며 이런 변수가 있다면 쪼개야 한다. 수집 변수가 아니라면 예외는 없다.

**절차**

1. 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수 이름을 바꾼다.
2. 가능하면 불변으로 선언한다.
3. 변수에 두 번째로 값을 대입하는 곳 앞까지의 모든 참조를 새로운 변수 이름으로 바꾼다.
4. 두 번째 대입 시 변수를 원래 이름으로 다시 선언한다.
5. 테스트
6. 반복, 매 반복에서 변수를 새로운 이름으로 선언하고, 다음번 대입까지의 모든 참조를 새 변수명으로 바꾼다.

### 9.2 필드 이름 바꾸기

데이터 구조는 무슨 일이 벌어지는지를 이해하는 열쇠다. 중요한만큼 깔끔하게 관리해야하며 개발을 진행하며 더 깊이 이해하게 되는 부분을 지속적으로 프로그램에 반영해야 한다.

**절차**

1. 레코드 유효 범위가 제한적이라면 필드에 접근하는 모든 코드를 수정 후 테스트한다. 이후 단계는 필요없다.
2. 레코드 캡슐화
3. 캡슐화된 객체 안의 private 필드명 변경, 그에 맞게 내부 메서드 수정
4. 테스트
5. 생성자 매개변수 중 필드와 이름이 겹치는게 있다면 함수 선언 바꾸기로 변경
6. 접근자 이름 변경

### 9.3 파생 변수를 질의 함수로 바꾸기

가변 데이터는 서로 다른 두 코드를 이상한 방식으로 결합시키곤 한다. 한 쪽 코드의 수정 값이 연쇄효과를 일으켜 다른 쪽 코드에 문제를 야기하기도 한다. 이를 배제하는 것은 현실적으로 불가능하지만, 가변 데이터의 유효범위를 가능한 좁혀야 한다.

**절차**

1. 변수 값이 갱신되는 지점을 모두 찾는다. 필요하면 변수 쪼개기로 갱신 지점에서 변수를 분리한다.
2. 해당 변수의 값을 계산해주는 함수를 만든다.
3. 해당 변수가 사용되는 모든 곳에 assertion을 추가하여 함수 계산 결과가 변수의 값과 같은지 확인한다.
4. 테스트
5. 변수를 읽는 코드를 모두 함수 호출로 대체한다.
6. 테스트
7. 변수를 선언하고 갱신하는 코드를 없앤다.

### 9.4 참조를 값으로 바꾸기

객체를 다른 객체에 중첩하면 내부 객체를 참조 또는 값으로 취급할 수 있다. 값 객체는 자유롭게 활용하기 좋고, 다루기가 더 쉽다.

만약 특정 객체를 여러 객체에서 공유하고자 한다면 이번 리팩토링은 적용하면 안된다.

**절차**

1. 후보 클래스가 불변인지, 불변이 될 수 있는지 확인
2. **클래스의** **세터를 하나씩 제거**
   1. 세터를 호출하는 쪽에서 매번 새로운 객체를 대입하도록 수정
3. 값 객체의 필드들을 사용하는 동치성 비교(equals / hashcode) 메서드를 값 객체 내에 생성

### 9.5 값을 참조로 바꾸기

하나의 데이터 구조 안에 논리적으로 같은 제3의 데이터 구조를 참조하는 레코드가 여러 개 있을 때가 있다.

ex) 주문 목록 중 같은 고객이 요청한 주문들

1. 고객이 값인 경우 → 고객 데이터가 각 주문에 복사
2. 고객이 참조인 경우 → 여러 주문이 단 하나의 고객 데이터 참조

일반적으로는 같은 데이터를 복사하는 방식으로 사용하는데, 이 때 가장 큰 문제 상황은 데이터를 갱신해야 할 때다. 모든 복제본을 빠짐없이 갱신해야하기 때문이다. 따라서 이런 상황이라면 데이터를 모두 참조로 바꿔주는 게 좋다.

**절차**

1. 같은 부류에 속하는 객체들을 보관할 저장소 생성
2. 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인
3. 호스트 객체의 생성자들을 수정하여 필요한 객체를 저장소에서 찾도록 함

- 이거 예시 관련해서 얘기좀

### 9.6 매직 리터럴 바꾸기

소스코드에 등장하는 리터럴 값을 뜻을 드러내는 상수로 대체하면 좋다. 특히, 비교 로직의 경우 함수 호출을 통한 비교로 바꾸면 좋다.
