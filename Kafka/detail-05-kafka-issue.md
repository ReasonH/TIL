### 오프셋 관리

Consumed Offset (Current Offset)

컨슈머가 메시지를 어디까지 읽었는가를 나타낸다. 해당 오프셋을 통해 컨슈머가 읽어야 할 다음의 메시지 위치를 식별할 수 있다. 해당 오프셋은 컨슈머가 poll( )을 받을 때마다 자동으로 업데이트 된다. 해당 오프셋은 각각의 컨슈머가 관리한다.

Committed Offset

컨슈머가 메시지를 읽고 카프카에게 ‘여기까지의 오프셋을 처리했다’ 는 것을 알리는 Offset Commit 을 통해 업데이트되는 오프셋이다. 컨슈머의 프로세스가 실패하고 다시 시작되면 컨슈머가 다시 메시지를 읽게 될 시작점이 되는 오프셋이기도 하다. 해당 오프셋은 ___consumer_offsets_ 라고 하는 카프카의 내부 토픽에서 관리한다.

자동 커밋, 수동 커밋 두 가지 방식을 사용 가능하다.

### 순서 보장

메세지의 순서가 중요한 경우, partition의 수를 1로 두거나, 순서가 보장되어야 하는 메세지는 같은 partition에 들어가도록 partition key를 적절히 설정하여야 한다.

**파티션 갯수 변경 주의점**

파티션 개수가 변경될 경우 키와 파티션 번호 매칭은 깨진다. 따라서 메시지 키를 활용할 때는 파티션 개수를 처음부터 여유있게 할당하는게 좋다.

### 리벨런싱 상황

컨슈머 그룹에서 아래와 같은 상황이 발생한다면 리벨런싱이 일어난다.

1. 컨슈머가 갑자기 다운될 경우 (heartbeat, poll 간격 등을 이용한 자체 판단)
2. 컨슈머 그룹에 새로운 컨슈머가 조인할 경우

이 때는 Committed Offset을 기반으로 리벨런싱이 일어난다.

### 중복 관리

- 자동 커밋 사용 시, 자동 커밋 간격 간 리벨런싱 일어나면 중복 consume이 수행될 수 있다.
- 수동 커밋 사용 시, 메시지 처리 과정에서 Exception이 발생할 때 중복 cosnume이 수행될 수 있다.

즉 중복을 완전히 막을 수 없기 때문에 적절한 멱등성 보장이 필요하다.

⇒ Transaction으로 묶는다던가?

### Retry와 DLT

consume 시 처리될 수 없는 메시지를 영영 재시도 하는 경우 뒤의 메시지들이 모두 소비되지 못한다.

따라서 처리 불가한 메시지를 다른 큐로 보내는 등의 조치가 필요하다.