## 프로듀서

### 프로듀서 기본 흐름

1. 클라이언트에서 send() 호출
2. Serializer를 통해 byte 배열로 변환
3. Partitioner를 통한 파티션 결정
4. 버퍼에 배치 단위로 메세지 누적
5. Sender가 배치 단위로 브로커에 전송

### Sender 기본 동작

send() 메서드는 계속해서 레코드를 누적시킨다. 이 때 별도 스레드로 수행되는 Sender는 누적된 레코드를 차례로 읽어 브로커에 전송한다. Sender가 메세지를 보낼 때는 배치 단위를 사용하는데, 해당 배치 내의 메세지 건 수와 관계없이 보낼 수 있는 상황이 되면 즉시 메세지를 브로커로 전송한다.

### 처리량 관련 주요 속성

`batch.size`: 배치 크기, 배치가 다 차면 바로 전송한다. 너무 작으면 전송 횟수가 많아지고 처리량이 떨어진다.

`linger.ms`: 대기 시간이 없으면 배치를 바로 전송, 대기 시간을 주면 그 시간만큼 기다렸다 배치를 전송한다. 대기 시간을 주면 전반적인 처리량이 늘어난다.

### 전송 결과 확인과 실패 처리

1. 확인 안함
2. 전송 결과 확인: Future
    
    메세지 하나 send()할 때마다 blocking 되기 때문에 배치 효과가 떨어진다.
    
3. 전송 결과 확인: Callback 방식
    
    blocking이 없기 때문에 처리량 저하가 없다.
    

### 전송 보장과 ACK

ack = 0: 서버 응답을 기다리지 않음, 전송 보장 X

ack = 1: 리더에 저장되면 응답, 리더 장애시 메세지 유실

ack = all: 모든 리플리카 저장시 응답

### min.insync.replicas

ack = all인 경우 브로커에 위 옵션을 지정해 성공 응답 조건을 정한다.

> ex1)
> 
> - 리플리카: 3
> - `min.insync.replicas` : 2
> 
> 이 경우 리더에 먼저 저장 → 팔로워 중 1개에 저장하면 성공을 응답한다.
> 
> ex2)
> 
> - 리플리카: 3
> - `min.insync.replicas`: 1
> 
> 이 경우 리더에 저장되면 성공을 응답한다. 리더 장애시 메세지 유실 가능성이 있으며 이는 ack = 1과 동일하다.
> 
> ex3)
> 
> - 리플리카: 3
> - `min.insync.replicas`: 3
> 
> 리더 및 팔로워 모두에 저장되야 성공을 응답한다. 하나라도 장애나면 리플리카 부족으로 실패한다. 이 옵션은 리플리카 갯수와 동일하게 지정하면 안된다.


### 에러 유형

전송 과정에서의 실패

- 전송 타임아웃, 리더 다운으로 인한 새로운 리더 선출 중, 메세지 크기 초과

전송 전에 실패

- 직렬화 실패, 프로듀서 자체 요청 크기 제한 초과
- 프로듀서 버퍼가 차서 기다린 시간이 최대 대기 시간 초과

### 실패 대응1: 재시도

재시도 가능한 에러는 재시도하는 방법

**재시도 위치**

- 프로듀서는 브로커 전송 과정에서 에러가 발생하면 재시도 가능한 에러에 대해 자체적으로 재시도 한다.
- send()에서 예외 발생 시 타입에 따라 send() 재호출
- 콜백 메서드에서 예외 받은 경우 타입에 따라 send() 재호출 등

무한 재시도 금지

### 실패 대응2: 기록

별도 파일, DB 등을 통해 실패한 메세지를 기록하고 추후 보정 작업 진행

### 재시도와 메세지 중복 가능성

브로커의 ack가 늦게와서 재시도할 경우 중복 발송이 가능하다.

![Untitled](/Kafka/img/01.png)

`enable.idempotence` 속성으로 중복 전송 가능성을 줄일 수 있다.

### 재시도와 순서

`max.in.flight.requests.per.connection`

- blocking 없이 한 **커넥션**에서 전송 가능한 최대 전송중인 요청의 갯수
- 이 값이 1보다 크면 재시도 시점에 따라 메세지 순서가 바뀔 수 있음
    - 전송 순서가 중요한 경우 해당 옵션을 1로 지정해야 한다.