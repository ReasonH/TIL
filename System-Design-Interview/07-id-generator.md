# 7. 분산 시스템을 위한 유일 ID 생성기 설계

auto_increment 속성이 설정된 관계형 DB의 기본 키는 분산 환경에서 지연을 낮추기 힘들다.

## 1단계 문제 이해 및 설계 범위 확정

- ID는 유일해야 한다
- ID는 숫자로만 구성되어야 한다
- ID는 64비트로 표현될 수 있는 값이어야 한다
- ID는 발급 날짜에 따라 정렬 가능해야 한다
- 초당 10,000개의 ID를 만들 수 있어야 한다

## 2단계 개략적 설계안 제시 및 동의 구하기

우리는 다음과 같은 선택지를 살펴본다

- 다중 마스터 복제
- UUID
- 티켓 서버
- 트위터 스노우플레이크 접근법

### 다중 마스터 복제

이는 DB의 auto_increment 기능을 활용하는 것이다. 다음 ID를 구할 때는 1이 아닌 k만큼을 증가시키는데, 이 때 k는 현재 DB 서버의 수가 된다. 이를 이용하는 경우 DB를 늘리면 초당 생산 가능한 ID 수도 늘릴 수 있다.

단점

- 여러 데이터 센터에 거쳐 규모를 늘리기 어렵다.
- 유일성은 보장되지만 시간 흐름에 맞추어 커지도록 보장할 수 없다.
    - ex) 2개 서버 A, B가 있는 경우 A서버의 3번 ID가 B서버의 2번 ID보다 먼저 발행될 수 있음
- 서버를 추가/삭제할 때 잘 동작하도록 만들기 어렵다.

### UUID

UUID: 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트 수 → 충돌이 생길 확률은 극히 낮다.

UUID는 서버 간 조율 없이 독립적으로 생성 가능하다. 따라서 동기화 이슈도 없고, 규모 확장도 쉽다.

단점

- ID가 128비트로 길다. (현재 요구사항은 64비트임)
- 시간 순 정렬이 불가능하다.
- ID에 숫자가 아닌 값이 포함될 수 있다.

### 티켓 서버

auto_increment 기능을 갖춘 티켓 서버를 중앙 집중형으로 하나만 사용하는 방식이다. 구현이 쉽고, 유일성이 보장되는 숫자로만 구성된 ID를 쉽게 만들 수 있다.

단점

- SPOF가 될 수 있다.
- 이를 회피하기 위해 서버를 여러대 둔다면 데이터 동기화 문제가 생긴다.

### 스노우플레이크 접근법

생성해야 하는 ID의 구조를 여러 section으로 분리한다.

- 사인비트: 1비트를 할당한다. 음수와 양수를 구별하는 데 사용할 수 있다.
- 타임스탬프: 41비트를 할당한다. epoch 이후 몇 밀리초가 경과했는지를 나타낸다.
- 데이터센터 ID: 5비트를 할당한다. 따라서 32개 데이터 센터를 지원할 수 있다.
- 서버 ID: 5비트를 할당한다. 따라서 데이터 센터 당 32개 서버를 사용할 수 있다.
- 일련번호: 12비트를 할당한다. 각 서버에서 ID를 생성할 때마다 일련번호를 1만큼 증가시킨다. 이 값은 1밀리초가 경과할 때마다 0으로 초기화된다.

## 3단계 상세 설계

스노우플레이크 ID 구조에서 데이터센터 ID와 서버 ID는 시스템 시작 시 결정되는 값이다. 반면 타임스탬프와 일련번호는 ID 생성기가 가동중일 때 만들어지는 값이다.

### 타임스탬프

타임스탬프는 시간의 흐름에 따라 점점 큰 값을 갖게 되므로 ID는 시간 순 정렬이 가능하게 된다.

### 일련번호

일련번호는 특정 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어낸 경우에만 0보다 큰 값을 갖게 된다.

## 4단계 마무리

스노우플레이크는 모든 요구사항을 충족시키며 분산 환경에서의 규모 확장을 가능하게 한다.

추가 논의해볼만한 사항

1. 시계 동기화
    
    서버가 여러 코어나 독립된 여러개의 물리장비에서 실행되는 경우 동일한 시계를 사용한다는 가정은 유효하지 않다. NTP는 이 문제를 해결하는 보편적 수단이다.
    
2. section 길이 최적화
    
    동시성이 낮고, 수명이 긴 애플리케이션이라면? → 일련번호 섹션을 줄이고, 타임스탬프 섹션 길이를 늘릴 수 있다.
    
3. 고가용성
    
    ID생성기는 아주 높은 가용성을 제공해야 한다.