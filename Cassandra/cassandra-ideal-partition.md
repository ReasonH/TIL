# Cassandra Data Partitioning

분산 데이터 시스템에서는 데이터를 '파티션'이라는 덩어리로 분산합니다. 복제, 데이터 배포, 인덱싱과 같은 기능은 파티션을 원자 단위로 사용한다. 데이터 분할은 일반적으로 ID, 해싱 등과 같은 간단한 수학 함수를 사용하여 수행된다. 이 함수는 '파티션 키'를 사용하여 데이터를 개별 파티션으로 그룹화한다.

Cassandra 또한 데이터를 파티션으로 나누고 관리한다. 파티션 키는 파티셔너를 통해 토큰으로 변환되며 각 클러스터 노드는 토큰 메커니즘을 통해 파티션 세트를 소유한다. 읽기 및 쓰기 작업은 테이블의 파티션 키를 사용해 수행된다.

### 파티션의 영향

클러스터 전체에 데이터를 균일하게 배포하고 우수한 I/O 성능을 얻기 위해서는 각 파티션에 저장된 데이터 크기를 제어하는 것이 필수적이다.

다음은 파티셔닝이 Cassandra Cluster에 미치는 영향이다.
1. 읽기 성능: 파티션이 크면 SSTable 데이터 관리, 유지하는데 성능 저하를 초래한다.
2. 메모리 사용: 파티션 크기는 JVM 힙 크기와 GC 메커니즘에 직접적 영향을 준다.
3. 데이터 복구: 파티션 크기가 큰 경우 데이터 복구 작업 시 발생하는 스트리밍 작업을 어렵게 만든다.
4. Tombstones Eviction: 삭제/압축 전략을 적절히 구현하지 않으면 데이터 퇴거에 어려움을 겪을 수 있다.

파티션 키 설정 시에는 이러한 영향도와 데이터 엑세스 패턴, 이상적 크기 등을 요인들을 고려해야 한다. 대표적인 예시로 이상적인 CQL 쿼리에는 항상 **단일 파티션 키**가 있어야 한다. 즉, 쿼리가 단일 파티션으로부터 데이터를 가져오도록 할 때 가장 효율적으로 작동한다.

### 파티셔닝 키 디지인

파티션 크기는 일반적으로 100MB, 이상적으로는 10MB 미만이어야 한다. 
- 파티션 키는 엑세스 패턴을 충족하고, 파티션에 맞는 이상적인 데이터 양을 갖도록 설계되어야 한다.
- 파티션 키는 제한되지 않은(크기가 무한히 증가하는) 파티션을 허용해서는 안된다.
- 파티션 키는 파티션 왜곡을 생성해서는 안된다. 불균형이 발생하지 않도록 특성을 도입해야 한다.

로그를 적재하는 server_logs 테이블을 가정하자. serverId를 유일한 partition key로 사용한다면 각 파티션은 무한히 증가하게 된다. 따라서 log_hour 등을 복합 파티션 키로 사용하여 파티션 경계를 지정할 수 있다.

partition key: `(server, log_hour)`

또한, 특정 서버에 log가 몰리는 경우를 대비하기 위해 더미 열 등을 추가할 수도 있다. 일례로 smallint 등의 더미 열을 추가할 수 있다.
1) 초기에는 smallint를 1로 사용한다.
2) 파티션에 충분한 행이 생기는 경우 smaillint를 2로 변경해서 적재한다.

partition key: `(server, log_hour, smallint)`

위의 예시와 같이 시계열 데이터는 파티션 키의 시간 요소를 사용해 분할할 수 있는 대표적인 사례다. 이는
- 무제한 파티션을 방지
- 엑세스 시 시간 범위를 통해 데이터 쿼리가 가능
- 데이터 삭제는 기간 등을 사용해 수행 가능

---
참고
- https://www.instaclustr.com/blog/cassandra-data-partitioning/#:~:text=The%20ideal%20size%20of%20a,size%20in%20the%20ideal%20range